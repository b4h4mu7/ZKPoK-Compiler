\chapter{Custom framework}

\section{Motivation}

The C code generated by CACE uses GNU GMP which is a multi-precision
arithmetic library. This library is tailored for desktop computers
and is not well suited for small embedded devices. The ZKPDL library
is an interpreter library which is also not well suited for small
embedded devices.

The custom framework build withing the course of this thesis will
attempt to combine the advantages from both projects. As the CACE
project is deemed more suited for the task, the custom framework
will extend CACE. The custom framework will aim to be a compiler
that can produce:
\begin{itemize}
\item Interpreted code
\item JIT (Just In Time) compiled code
\item Compiled code
\end{itemize}

LLVM was chosen as the compiler infrastructure. Its intermediate
form (LLVM IR) is of SSA (Static Single Assignment) form which
allows easy extraction of DFG (Data Flow Graph). This allows
for more aggressive optimization as well as conversion directly
to HDL (Hardware Description Language).

\filbreak

\section{Extensions to GEZEL}

A modification to GEZEL was needed to allow interactivity. A terminal
ipblock was made during the course of this thesis. This ipblock allows
connecting to the host via pseudo-terminals or to other devices via
serial ports.

The ipblock terminal is based on POSIX termios functionality so this
limits the simulator availability to POSIX systems.

\section{Extensions to CACE}

Extensions to the CACE frameworks are presented in Figure
\ref{fig:custom_framework_workflow}. 
The custom part is
further explained in Figure \ref{fig:custom_llvm_workflow}.

\begin{figure}[hbt!]
  \centering
    \begin{tikzpicture}[>=stealth,level distance=1.5cm, font=\tiny]
    \tikzstyle{edge from parent}=[draw,->]
    \tikzset{every leaf node/.style={anchor=center}}

    \Tree [.\node[language](psl){Protocol \\ Specification \\ Language (PSL)};
      [.\node[compiler](pc){Protocol \\ Compiler};
        [.\node[language](pil){Protocol \\ Implementation \\ Language (PIL)};
          [.\node[compiler,added](llvm){LLVM};
            \node[language,added](asm){x86 \\ x86-64 \\ MIPS \\ARM \\ \emph{8051}};
            \node[language,added](gezel){GEZEL \\ VHDL \\ Verilog};
          ]
          [.\node[compiler](c){C}; \node[language](code){Code};]
          [.\node[compiler](latex){\LaTeX}; \node[language](doc){Documentation};]
        ]
      ]
    ]

    \node[compiler] (pvt)         [right=of pc,anchor=west]          {Protocol \\ Verification \\ Toolbox}
    child {node[language] {Proof of \\ Soundness}};

    \node[compiler] (sigma) [left=of pil.north west,anchor=center] {$\Sigma 2 N I Z K$};
    \node[compiler] (cost) [left=of pil.south west,anchor=center] {Costs};

    \draw[<->] (sigma) -- (pil);
    \draw[<->] (cost) -- (pil);

    \draw[->] (psl) -- (pvt);
    \draw[->] (pil) -- (pvt);
  \end{tikzpicture}
  \caption{Custom framework (extensions to CACE highlighted)}
  \label{fig:custom_framework_workflow}
\end{figure}

\begin{figure}[hbt!]
  \centering
  \begin{tikzpicture}[>=stealth]
    \tikzstyle{lang}=[rectangle,draw=black,thin,font=\tiny,inner
    sep=0pt, align=center,minimum width=2.7cm,minimum height=2.2em]

    \tikzstyle{txt}=[font=\tiny]

    \node[lang](llvm_opt){LLVM \\ Optimizer};
    \node[lang](ppc_back)[right=1 cm of llvm_opt]{LLVM \\ PowerPC Backend};
    \node[txt](ppc)[right=of ppc_back]{PowerPC};
    \node[lang](x86_back)[above of=ppc_back]{LLVM \\ x86 Backend};
    \node[txt](x86)[right=of x86_back]{x86};
    \node[lang](arm_back)[below of=ppc_back]{LLVM \\ ARM Backend};
    \node[txt](arm)[right=of arm_back]{ARM};
    \node[lang,added](8051_back)[below of=arm_back]{Custom \\ 8051 Backend};
    \node[txt](8051)[right=of 8051_back]{8051};
    \node[lang,added](gezel_back)[below of=8051_back]{Custom \\ GEZEL Backend};
    \node[txt](gezel)[right=of gezel_back]{GEZEL};

    \node[lang,added](pil_front)[left=1 cm of llvm_opt]{PIL \\ Frontend};
    \node[txt](pil)[left=of gcc_front]{PIL};

    \draw[->] (gcc_front.east) -- (llvm_opt.west);

    \draw[->] (llvm_opt.east) -- (x86_back.west);
    \draw[->] (llvm_opt.east) -- (ppc_back.west);
    \draw[->] (llvm_opt.east) -- (arm_back.west);

    \draw[->] (x86_back) -- (x86);
    \draw[->] (ppc_back) -- (ppc);
    \draw[->] (arm_back) -- (arm);

    \draw[->] (pil) -- (pil_front);

    \draw[->] (llvm_opt.east) -- (8051_back.west);
    \draw[->] (llvm_opt.east) -- (gezel_back.west);

    \draw[->] (8051_back) -- (8051);
    \draw[->] (gezel_back) -- (gezel);
  \end{tikzpicture}
  \caption{LLVM custom workflow (changes highlighted)}
  \label{fig:custom_llvm_workflow}
\end{figure}

\newpage

\section{PIL frontend}

PIL frontend flow is depicted in Figure \ref{fig:parser_flow}.  An
input PIL is read by the Lexer producing input for the Parser. The
Parser reads these and generates an abstract syntax tree (AST) which
is fed to the Codegen tree-walker that generates the code (in the form
of LLVM IR). Both the lexer grammar and the parser grammar are
specified in the file pil.g. The tree-walker and the code generator is
specified in the file codegen.g.

\begin{figure}[hbt!]
  \centering
  \begin{tikzpicture}[>=stealth]
    \node[language] (pil) {PIL};
    \node[compiler] (lexer) [right=of pil] {Lexer};
    \node[compiler] (parser) [right=of lexer] {Parser};
    \node[language] (ast) [right=of parser] {AST};
    \node[compiler] (codegen) [right=of ast] {Codegen};
    \node[language] (llvm_ir) [right=of codegen] {LLVM IR};

    \draw[->] (pil) -- (lexer);
    \draw[->] (lexer) -- (parser);
    \draw[->] (parser) -- (ast);
    \draw[->] (ast) -- (codegen);
    \draw[->] (codegen) -- (llvm_ir);
  \end{tikzpicture}
  \caption{PIL frontend flow}
  \label{fig:parser_flow}
\end{figure}

\filbreak

The code generation process generates one module per block. The Common
block module is augmented with the functions provided by the VM.
Every other block except the Common block gets a Common block linked
in. This process is depicted in Figure \ref{fig:linker}.

\begin{figure}[hbt!]
  \centering
  \begin{tikzpicture}[>=stealth]
    \node[language] (block) {Block};
    \node[compiler] (linker) [right=of block] {Linker};
    \node[language] (common) [above=of linker] {Common};
    \node[language] (module) [right=of linker] {Module};

    \draw[->] (block) -- (linker);
    \draw[->] (common) -- (linker);
    \draw[->] (linker) -- (module);
  \end{tikzpicture}
  \caption{Linker}
  \label{fig:linker}
\end{figure}

\section{Coprocessor design}

The coprocessor has:
\begin{itemize}
\item 6 1024-bit registers (u, v, p, R, S, Q)
\item 1 1024-bit datapath (adder and a shifter)
\item 10-bit datapaths and registers for loop and address counters
\end{itemize}

\noindent
The shared memory is used in the following way:
\begin{itemize}
\item 0x600--0x680 1024-bit number
\item 0x680--0x700 1024-bit number
\item 0x700--0x780 1024-bit number
\item 0x780--0x800 command queue (up to 128 commands)
\item 0x800 state signaling from the coprocessor
\end{itemize}

\noindent
The instructions are the following:
\begin{itemize}
\item Halt - stops the execution of the coprocessor and signals the
  done to the main processor
\item Init - initializes the coprocessor (just sets the modulus for now)
\item Montgomery multiplication - executes the Montgomery
  multiplication on the registers u and v and stores the result back
  to u
\item Montgomery squaring - executes the Montgomery squaring of the
  register u and stores the result back to u
\item Montgomery inversion - executes the Montgomery inversion of the
  register u and stores the result back to u (destroys the previous
  values of u and v)
\item Load u from the shared memory - loads the register u from the
  shared memory location 0x00 or 0x80 or 0x100
\item Load v from the shared memory - loads the register v from the
  shared memory location 0x00 or 0x80 or 0x100
\item Store result to shared memory - stores the result of the
  operation to memory location 0x00 or 0x80 or 0x100
\item Store quotient to memory (Montgomery only) - stores the quotient
  of the Montgomery operation to memory location 0x00 or 0x80 or 0x100
\end{itemize}

Special instructions were provided for loading from shared memory
because the coprocessor is 24 times faster with loading from memory
(12 clock cycles for 1 instruction cycle, 2 instruction cycles for
loading on the processor). This way, a third parameter can be stored
in the shared memory for faster fetching.

\subsection{Command queueing}

The idea is to allocate special storage in the shared memory for the
commands the coprocessor should execute. The main processor then
simply fills this memory with the commands the coprocessor needs to
execute. The main processor then starts the coprocessor which will
execute these instructions.

This is also useful if the main processor should be able to perform
other operations while the coprocessor executes the commands
provided. The method has also been tested with the main processor
being slower $144$ (additional $12\textrm{x}$ slowdown) times than the
coprocessor and it gave satisfying results (only $5\textrm{x}$
increase in cycle numbers for RSA).

\subsection{Datapath}

The datapath design revolves around a 1024-bit adder and a shifter in
series. The shifter can shift one position to the left, one position
to the right or just pass the input.

The inputs to the adder are multiplexed between 0, 1, u, v, p, R, S,
power for the x operand. For the v operand, the multiplication step is
multiplexed instead of the power.

The result always gets assigned back to u. This was to allow chaining
of Montgomery multiplications when exponentiation is performed. This
way, no redundant copying is necessary from/to the shared memory. What
is also possible this way is to update the shared memory while the
coprocessor is executing (this helps the elimination of the
communication overhead). The technique was not tested within
this project.

\subsection{Modifications to the Montgomery product}

The Montgomery product computation algorithm has been modified to
include computing the quotient (as is called in
\cite{monpro_doubling}). This allows for doubling the bit-length
(\cite{monpro_doubling, classic_doubling}) of the crypto-coprocessor
in software. This technique was not tested within this project.

\subsection{Software in C}

A library is provided exposing primitives which are executed on the
coprocessor:
\begin{itemize}
\item montpro - Montgomery product
\item montinv - Montgomery inversion
\item modexp - Modular exponentiation
\end{itemize}

\noindent
Also provided are the following software methods:
\begin{itemize}
\item add1024 - adding 1024-bit numbers
\item subtract1024 - subtracting 1024-bit numbers
\item multiply1024 - multiplies 1024-bit numbers to produce a 2048-bit
\item larger\_or\_equal - checks if the number is larger or equal than a number
\end{itemize}

These operations were left in software as they were already fast
enough there. Multiplication was left in case someone would want to
use the bit doubling method. These functions are documented in the
lib.h header file.

\subsection{Hardware in VHDL}

During the co-design phase, separate datapaths were made for the adder
and the bit shifter.  This was to allow a different implementation in
VHDL as the GEZEL-to-VHDL tool (fdlvhd) generates one .vhd file per
datapath. The target devices usually have sophisticated CLA logic
implemented so that efficient adders in terms of space and speed can
be generated.

The same reasoning goes for ASIC design. Usually the libraries
provided from the foundries will include efficient designs of adders
which can be combined to produce the required adder. Even if they
don't, having a separate block allows the designer to concentrate more
on where optimization really counts (critical data path, major effect
on area).

In our specific case, the GEZEL-to-VHDL tool generated 2 1024-bit
adders, one with carry-in and one without it. Manual intervention was
required to change it to a single 1024-bit adder with carry-in. Later
on 2 513-bit adders were used to reduce the slice count even further.
Putting 2 smaller adders helped the synthesis tool spread out and
perform better interconnect.
Custom add\_sub.customxx.vhd are provided in the vhdl subfolder.

%%% Local Variables: 
%%% TeX-PDF-mode: t
%%% TeX-master: "thesis"
%%% End: 
