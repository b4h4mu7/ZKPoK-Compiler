/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : codegen.g
 *     -                            On : 2012-10-06 00:12:03
 *     -           for the tree parser : codegenTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "codegen.h"

	struct cmp_str
	{
		bool operator()(const char *a, const char *b)
		{
			return strcmp(a, b) < 0;
		}
	};
	
	static Module *Common = new Module("Common", getGlobalContext());
	static Module *TheModule;
	static IRBuilder<> Builder(getGlobalContext());
	static stack< map<const char*, Variable, cmp_str>* > Vars;
	static map<const char*, NumberT*, cmp_str> Types;
				
	Value* operator_call(const char *name, Intrinsic::ID id, Value *a, Value *b, Value *mod)
	{
		vector<Type*> types;
		
		types.push_back(mod->getType());
		types.push_back(a->getType());
		types.push_back(b->getType());
		types.push_back(mod->getType());
	
		Function *function = Intrinsic::getDeclaration(TheModule, id, types);
		
		vector<Value*> args;
		
		args.push_back(a);
		args.push_back(b);
		args.push_back(mod);
		
		return Builder.CreateCall(function, args, name);
	}
	
	void init_common() 
	{	
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(1, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "CheckMembership", Common);
		
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(1, Type::getInt1Ty(getGlobalContext())),
				false),
			Function::ExternalLinkage, "Verify", Common);
	}

	NumberT *NumberT::addWithSubFrom(const NumberT *first) const { return const_cast<NumberT*>(first); }
	NumberT *NumberT::addWithSubFrom(const GroupT *first) const { return const_cast<GroupT*>(first); }
	  
	NumberT *NumberT::mulWithExpOn(const NumberT *first) const { return const_cast<NumberT*>(first); }
	NumberT *NumberT::mulWithExpOn(const GroupT *first) const { return const_cast<GroupT*>(first); }
	
	Value * NumberT::createNeg(const char *id, Value *a) const  {
		return Builder.CreateNeg(a, id);
	}
	
	Value * NumberT::createAdd(const char *id, Value *a, Value *b) const {
		return Builder.CreateAdd(a, b, id);
	}
	
	Value * NumberT::createSub(const char *id, Value *a, Value *b) const {
		return Builder.CreateSub(a, b, id);
	}
	
	Value * NumberT::createMul(const char *id, Value *a, Value *b) const {
		return Builder.CreateMul(a, b, id);
	}
	
	Value * NumberT::createExp(const char *id, Value *a, Value *b) const {
		return Builder.CreateMul(a, b, id);
	}
	
	Value * GroupT::createNeg(const char *id, Value *a) const {
		return operator_call(id, Intrinsic::modsub, ConstantInt::get(getGlobalContext(), APInt(1024, 0)), a, this->getModulusConstant());
	}
	
	Value * GroupT::createAdd(const char *id, Value *a, Value *b) const {
		return operator_call(id, Intrinsic::modadd, a, b, this->getModulusConstant()); 	
	}
	
	Value * GroupT::createSub(const char *id, Value *a, Value *b) const {
		return operator_call(id, Intrinsic::modsub, a, b, this->getModulusConstant()); 		
	}
	
	Value * GroupT::createMul(const char *id, Value *a, Value *b) const {
		return operator_call(id, Intrinsic::modmul, a, b, this->getModulusConstant()); 	
	}
	
	Value * GroupT::createExp(const char *id, Value *a, Value *b) const {
		return operator_call(id, Intrinsic::modexp, a, b, this->getModulusConstant()); 	
	}

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pcodegen_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcodegen_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pcodegen_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pcodegen_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   codegenTokenNames[48+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BODY",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "IDENT",
        (pANTLR3_UINT8) "INP",
        (pANTLR3_UINT8) "INTERVAL",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "ORDER",
        (pANTLR3_UINT8) "OUTPUT",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PROOF",
        (pANTLR3_UINT8) "VARIABLE",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'CheckMembership'",
        (pANTLR3_UINT8) "'Def'",
        (pANTLR3_UINT8) "'Else'",
        (pANTLR3_UINT8) "'ExecutionOrder'",
        (pANTLR3_UINT8) "'IfKnown'",
        (pANTLR3_UINT8) "'Int'",
        (pANTLR3_UINT8) "'Prime'",
        (pANTLR3_UINT8) "'Random'",
        (pANTLR3_UINT8) "'SHA256'",
        (pANTLR3_UINT8) "'Verify'",
        (pANTLR3_UINT8) "'Void'",
        (pANTLR3_UINT8) "'Z'",
        (pANTLR3_UINT8) "'Zmod*'",
        (pANTLR3_UINT8) "'Zmod+'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	proof    (pcodegen ctx, const char *part);
static 
 void
	execution_order    (pcodegen ctx);
static 
 void
	step    (pcodegen ctx);
static 
 void
	common    (pcodegen ctx);
static 
 void
	block    (pcodegen ctx, const char *part);
static 
 void
	param    (pcodegen ctx);
static 
 void
	global    (pcodegen ctx);
static 
 void
	function    (pcodegen ctx);
static 
 Value *
	param_declaration    (pcodegen ctx);
static 
 Value *
	global_declaration    (pcodegen ctx);
static 
 Arg *
	argument_declaration    (pcodegen ctx);
static 
 NumberT *
	type_declaration    (pcodegen ctx);
static 
 codegen_function_declaration_return
	function_declaration    (pcodegen ctx);
static 
 void
	body    (pcodegen ctx);
static 
 void
	statement    (pcodegen ctx);
static 
 Value *
	assignment    (pcodegen ctx);
static 
 Value *
	concat    (pcodegen ctx, const char *id);
static 
 codegen_hash_return
	hash    (pcodegen ctx, const char *id);
static 
 codegen_function_call_return
	function_call    (pcodegen ctx, const char *id);
static 
 Value *
	argument    (pcodegen ctx);
static 
 NumberT *
	group    (pcodegen ctx);
static 
 NumberT *
	alias    (pcodegen ctx);
static 
 NumberT *
	interval    (pcodegen ctx);
static 
 codegen_expr_return
	expr    (pcodegen ctx, const char *id);
static 
 ANTLR3_BOOLEAN
	synpred1_codegen    (pcodegen ctx);
static void	codegenFree(pcodegen ctx);
static void     codegenReset (pcodegen ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "codegen.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return codegenNewSSD(instream, NULL);
}

/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcodegen ctx;	    /* Context structure we will build and return   */

    ctx	= (pcodegen) ANTLR3_CALLOC(1, sizeof(codegen));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in codegen.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our codegen interface
     */
    ctx->proof	= proof;
    ctx->execution_order	= execution_order;
    ctx->step	= step;
    ctx->common	= common;
    ctx->block	= block;
    ctx->param	= param;
    ctx->global	= global;
    ctx->function	= function;
    ctx->param_declaration	= param_declaration;
    ctx->global_declaration	= global_declaration;
    ctx->argument_declaration	= argument_declaration;
    ctx->type_declaration	= type_declaration;
    ctx->function_declaration	= function_declaration;
    ctx->body	= body;
    ctx->statement	= statement;
    ctx->assignment	= assignment;
    ctx->concat	= concat;
    ctx->hash	= hash;
    ctx->function_call	= function_call;
    ctx->argument	= argument;
    ctx->group	= group;
    ctx->alias	= alias;
    ctx->interval	= interval;
    ctx->expr	= expr;
    ctx->synpred1_codegen	= synpred1_codegen;
    ctx->free			= codegenFree;
    ctx->reset			= codegenReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = codegenTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
codegenReset (pcodegen ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 codegenFree(pcodegen ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return codegenTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROOF_in_proof51  */
static	ANTLR3_BITWORD FOLLOW_PROOF_in_proof51_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PROOF_in_proof51	= { FOLLOW_PROOF_in_proof51_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_execution_order_in_proof53  */
static	ANTLR3_BITWORD FOLLOW_execution_order_in_proof53_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_execution_order_in_proof53	= { FOLLOW_execution_order_in_proof53_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_in_proof55  */
static	ANTLR3_BITWORD FOLLOW_common_in_proof55_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000018) };
static  ANTLR3_BITSET_LIST FOLLOW_common_in_proof55	= { FOLLOW_common_in_proof55_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_proof58  */
static	ANTLR3_BITWORD FOLLOW_block_in_proof58_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000018) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_proof58	= { FOLLOW_block_in_proof58_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ORDER_in_execution_order78  */
static	ANTLR3_BITWORD FOLLOW_ORDER_in_execution_order78_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ORDER_in_execution_order78	= { FOLLOW_ORDER_in_execution_order78_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_step_in_execution_order81  */
static	ANTLR3_BITWORD FOLLOW_step_in_execution_order81_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_step_in_execution_order81	= { FOLLOW_step_in_execution_order81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_step96  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_step96_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_step96	= { FOLLOW_IDENT_in_step96_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_step98  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_step98_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_step98	= { FOLLOW_IDENT_in_step98_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_common110  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_common110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_common110	= { FOLLOW_BLOCK_in_common110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_common113  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_common113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_common113	= { FOLLOW_IDENT_in_common113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_common117  */
static	ANTLR3_BITWORD FOLLOW_param_in_common117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020088) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_common117	= { FOLLOW_param_in_common117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_common120  */
static	ANTLR3_BITWORD FOLLOW_global_in_common120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000088) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_common120	= { FOLLOW_global_in_common120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_common123  */
static	ANTLR3_BITWORD FOLLOW_function_in_common123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_common123	= { FOLLOW_function_in_common123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block139  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block139	= { FOLLOW_BLOCK_in_block139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_block142  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_block142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_block142	= { FOLLOW_IDENT_in_block142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_block146  */
static	ANTLR3_BITWORD FOLLOW_param_in_block146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020088) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_block146	= { FOLLOW_param_in_block146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_block149  */
static	ANTLR3_BITWORD FOLLOW_global_in_block149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000088) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_block149	= { FOLLOW_global_in_block149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_block152  */
static	ANTLR3_BITWORD FOLLOW_function_in_block152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_block152	= { FOLLOW_function_in_block152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAM_in_param169  */
static	ANTLR3_BITWORD FOLLOW_PARAM_in_param169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAM_in_param169	= { FOLLOW_PARAM_in_param169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_declaration_in_param172  */
static	ANTLR3_BITWORD FOLLOW_param_declaration_in_param172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_param_declaration_in_param172	= { FOLLOW_param_declaration_in_param172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_global186  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_global186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_global186	= { FOLLOW_VARIABLE_in_global186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_declaration_in_global189  */
static	ANTLR3_BITWORD FOLLOW_global_declaration_in_global189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_global_declaration_in_global189	= { FOLLOW_global_declaration_in_global189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_function202  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_function202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_function202	= { FOLLOW_FUNCTION_in_function202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_declaration_in_function205  */
static	ANTLR3_BITWORD FOLLOW_function_declaration_in_function205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_function_declaration_in_function205	= { FOLLOW_function_declaration_in_function205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_param_declaration226  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_param_declaration226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_param_declaration226	= { FOLLOW_IDENT_in_param_declaration226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_param_declaration230  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_param_declaration230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_param_declaration230	= { FOLLOW_type_declaration_in_param_declaration230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_param_declaration236  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_param_declaration236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_param_declaration236	= { FOLLOW_NUMBER_in_param_declaration236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_global_declaration271  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_global_declaration271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_global_declaration271	= { FOLLOW_IDENT_in_global_declaration271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_global_declaration273  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_global_declaration273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_global_declaration273	= { FOLLOW_type_declaration_in_global_declaration273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_global_declaration279  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_global_declaration279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_global_declaration279	= { FOLLOW_NUMBER_in_global_declaration279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_argument_declaration312  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_argument_declaration312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_argument_declaration312	= { FOLLOW_IDENT_in_argument_declaration312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_argument_declaration314  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_argument_declaration314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_argument_declaration314	= { FOLLOW_type_declaration_in_argument_declaration314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_argument_declaration325  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_argument_declaration325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_argument_declaration325	= { FOLLOW_IDENT_in_argument_declaration325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_type_declaration343  */
static	ANTLR3_BITWORD FOLLOW_group_in_type_declaration343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_type_declaration343	= { FOLLOW_group_in_type_declaration343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_type_declaration350  */
static	ANTLR3_BITWORD FOLLOW_interval_in_type_declaration350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_type_declaration350	= { FOLLOW_interval_in_type_declaration350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_function_declaration368  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_function_declaration368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_function_declaration368	= { FOLLOW_IDENT_in_function_declaration368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPUT_in_function_declaration371  */
static	ANTLR3_BITWORD FOLLOW_OUTPUT_in_function_declaration371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPUT_in_function_declaration371	= { FOLLOW_OUTPUT_in_function_declaration371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_function_declaration374  */
static	ANTLR3_BITWORD FOLLOW_42_in_function_declaration374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_function_declaration374	= { FOLLOW_42_in_function_declaration374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration379  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration379	= { FOLLOW_argument_declaration_in_function_declaration379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INP_in_function_declaration392  */
static	ANTLR3_BITWORD FOLLOW_INP_in_function_declaration392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INP_in_function_declaration392	= { FOLLOW_INP_in_function_declaration392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_function_declaration395  */
static	ANTLR3_BITWORD FOLLOW_42_in_function_declaration395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_function_declaration395	= { FOLLOW_42_in_function_declaration395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration400  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration400	= { FOLLOW_argument_declaration_in_function_declaration400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_body_in_function_declaration416  */
static	ANTLR3_BITWORD FOLLOW_body_in_function_declaration416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_body_in_function_declaration416	= { FOLLOW_body_in_function_declaration416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BODY_in_body433  */
static	ANTLR3_BITWORD FOLLOW_BODY_in_body433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BODY_in_body433	= { FOLLOW_BODY_in_body433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_body435  */
static	ANTLR3_BITWORD FOLLOW_statement_in_body435_bits[]	= { ANTLR3_UINT64_LIT(0x0000038110000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_body435	= { FOLLOW_statement_in_body435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_statement449  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_statement449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_statement449	= { FOLLOW_assignment_in_statement449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_statement454  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_statement454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_statement454	= { FOLLOW_function_call_in_statement454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_assignment471  */
static	ANTLR3_BITWORD FOLLOW_28_in_assignment471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_assignment471	= { FOLLOW_28_in_assignment471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_assignment473  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_assignment473_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_assignment473	= { FOLLOW_IDENT_in_assignment473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignment475  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignment475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignment475	= { FOLLOW_expr_in_assignment475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_concat500  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_concat500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_concat500	= { FOLLOW_IDENT_in_concat500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_in_concat505  */
static	ANTLR3_BITWORD FOLLOW_hash_in_concat505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_in_concat505	= { FOLLOW_hash_in_concat505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_concat512  */
static	ANTLR3_BITWORD FOLLOW_50_in_concat512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_concat512	= { FOLLOW_50_in_concat512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_concat_in_concat514  */
static	ANTLR3_BITWORD FOLLOW_concat_in_concat514_bits[]	= { ANTLR3_UINT64_LIT(0x0004010000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_concat_in_concat514	= { FOLLOW_concat_in_concat514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_concat_in_concat517  */
static	ANTLR3_BITWORD FOLLOW_concat_in_concat517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_concat_in_concat517	= { FOLLOW_concat_in_concat517_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_hash538  */
static	ANTLR3_BITWORD FOLLOW_40_in_hash538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_hash538	= { FOLLOW_40_in_hash538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_concat_in_hash540  */
static	ANTLR3_BITWORD FOLLOW_concat_in_hash540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_concat_in_hash540	= { FOLLOW_concat_in_hash540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_function_call565  */
static	ANTLR3_BITWORD FOLLOW_39_in_function_call565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_function_call565	= { FOLLOW_39_in_function_call565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_function_call567  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_function_call567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_function_call567	= { FOLLOW_type_declaration_in_function_call567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_in_function_call577  */
static	ANTLR3_BITWORD FOLLOW_hash_in_function_call577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_in_function_call577	= { FOLLOW_hash_in_function_call577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_function_call588  */
static	ANTLR3_BITWORD FOLLOW_32_in_function_call588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_function_call588	= { FOLLOW_32_in_function_call588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_function_call590  */
static	ANTLR3_BITWORD FOLLOW_argument_in_function_call590_bits[]	= { ANTLR3_UINT64_LIT(0x0000386000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_function_call590	= { FOLLOW_argument_in_function_call590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_function_call592  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_function_call592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_function_call592	= { FOLLOW_type_declaration_in_function_call592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_function_call603  */
static	ANTLR3_BITWORD FOLLOW_41_in_function_call603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_function_call603	= { FOLLOW_41_in_function_call603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_function_call605  */
static	ANTLR3_BITWORD FOLLOW_expr_in_function_call605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_function_call605	= { FOLLOW_expr_in_function_call605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_argument628  */
static	ANTLR3_BITWORD FOLLOW_expr_in_argument628_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_argument628	= { FOLLOW_expr_in_argument628_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_argument636  */
static	ANTLR3_BITWORD FOLLOW_group_in_argument636_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_argument636	= { FOLLOW_group_in_argument636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_group651  */
static	ANTLR3_BITWORD FOLLOW_43_in_group651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_group651	= { FOLLOW_43_in_group651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_group659  */
static	ANTLR3_BITWORD FOLLOW_38_in_group659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_group659	= { FOLLOW_38_in_group659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group661  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group661	= { FOLLOW_expr_in_group661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_group671  */
static	ANTLR3_BITWORD FOLLOW_37_in_group671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_group671	= { FOLLOW_37_in_group671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group673  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group673	= { FOLLOW_expr_in_group673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_group683  */
static	ANTLR3_BITWORD FOLLOW_45_in_group683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_group683	= { FOLLOW_45_in_group683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_group685  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_group685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_group685	= { FOLLOW_IDENT_in_group685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_group694  */
static	ANTLR3_BITWORD FOLLOW_44_in_group694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_group694	= { FOLLOW_44_in_group694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_group696  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_group696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_group696	= { FOLLOW_IDENT_in_group696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_alias715  */
static	ANTLR3_BITWORD FOLLOW_30_in_alias715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_alias715	= { FOLLOW_30_in_alias715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_alias717  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_alias717_bits[]	= { ANTLR3_UINT64_LIT(0x0000386000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_alias717	= { FOLLOW_IDENT_in_alias717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_alias720  */
static	ANTLR3_BITWORD FOLLOW_group_in_alias720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_alias720	= { FOLLOW_group_in_alias720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_alias726  */
static	ANTLR3_BITWORD FOLLOW_interval_in_alias726_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_alias726	= { FOLLOW_interval_in_alias726_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTERVAL_in_interval750  */
static	ANTLR3_BITWORD FOLLOW_INTERVAL_in_interval750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INTERVAL_in_interval750	= { FOLLOW_INTERVAL_in_interval750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval752  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval752_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval752	= { FOLLOW_expr_in_interval752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval755  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval755	= { FOLLOW_expr_in_interval755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_expr777  */
static	ANTLR3_BITWORD FOLLOW_25_in_expr777_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_expr777	= { FOLLOW_25_in_expr777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr781  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr781	= { FOLLOW_expr_in_expr781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_expr791  */
static	ANTLR3_BITWORD FOLLOW_23_in_expr791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_expr791	= { FOLLOW_23_in_expr791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr795  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr795_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr795	= { FOLLOW_expr_in_expr795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr800  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr800	= { FOLLOW_expr_in_expr800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_expr810  */
static	ANTLR3_BITWORD FOLLOW_25_in_expr810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_expr810	= { FOLLOW_25_in_expr810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr814  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr814_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr814	= { FOLLOW_expr_in_expr814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr819  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr819	= { FOLLOW_expr_in_expr819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_expr829  */
static	ANTLR3_BITWORD FOLLOW_22_in_expr829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_expr829	= { FOLLOW_22_in_expr829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr833  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr833_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr833	= { FOLLOW_expr_in_expr833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr838  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr838	= { FOLLOW_expr_in_expr838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_expr848  */
static	ANTLR3_BITWORD FOLLOW_48_in_expr848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_expr848	= { FOLLOW_48_in_expr848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr852  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr852_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr852	= { FOLLOW_expr_in_expr852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr857  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr857	= { FOLLOW_expr_in_expr857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_expr867  */
static	ANTLR3_BITWORD FOLLOW_31_in_expr867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_expr867	= { FOLLOW_31_in_expr867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr871  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr871_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr871	= { FOLLOW_expr_in_expr871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr876  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr876	= { FOLLOW_expr_in_expr876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_expr886  */
static	ANTLR3_BITWORD FOLLOW_19_in_expr886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_expr886	= { FOLLOW_19_in_expr886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr890  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr890_bits[]	= { ANTLR3_UINT64_LIT(0x0001038182C81100) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr890	= { FOLLOW_expr_in_expr890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr895  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr895	= { FOLLOW_expr_in_expr895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_expr904  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_expr904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_expr904	= { FOLLOW_function_call_in_expr904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_expr912  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_expr912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_expr912	= { FOLLOW_IDENT_in_expr912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expr921  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expr921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expr921	= { FOLLOW_NUMBER_in_expr921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENT_in_synpred1_codegen302  */
static	ANTLR3_BITWORD FOLLOW_IDENT_in_synpred1_codegen302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENT_in_synpred1_codegen302	= { FOLLOW_IDENT_in_synpred1_codegen302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_synpred1_codegen304  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_synpred1_codegen304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_synpred1_codegen304	= { FOLLOW_type_declaration_in_synpred1_codegen304_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start proof
 * codegen.g:147:1: proof[const char *part] : ^( PROOF execution_order common ( block[$part] )* ) ;
 */
static void
proof(pcodegen ctx, const char *part)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:148:2: ( ^( PROOF execution_order common ( block[$part] )* ) )
        // codegen.g:148:4: ^( PROOF execution_order common ( block[$part] )* )
        {
            if ( BACKTRACKING==0 )
            {
                 init_common(); Vars.push(new map<const char*, Variable, cmp_str>()); 
            }


             MATCHT(PROOF, &FOLLOW_PROOF_in_proof51);
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            FOLLOWPUSH(FOLLOW_execution_order_in_proof53);
            execution_order(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            FOLLOWPUSH(FOLLOW_common_in_proof55);
            common(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            // codegen.g:148:107: ( block[$part] )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case BLOCK:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // codegen.g:148:108: block[$part]
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_proof58);
            	        block(ctx, part);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproofEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            if ( BACKTRACKING==0 )
            {
                 delete Vars.top(); Vars.pop(); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleproofEx; /* Prevent compiler warnings */
    ruleproofEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end proof */

/**
 * $ANTLR start execution_order
 * codegen.g:152:1: execution_order : ^( ORDER ( step )* ) ;
 */
static void
execution_order(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:153:2: ( ^( ORDER ( step )* ) )
        // codegen.g:153:4: ^( ORDER ( step )* )
        {
             MATCHT(ORDER, &FOLLOW_ORDER_in_execution_order78);
            if  (HASEXCEPTION())
            {
                goto ruleexecution_orderEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:153:12: ( step )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) )
                    {
                    case IDENT:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2)
                    {
                	case 1:
                	    // codegen.g:153:13: step
                	    {
                	        FOLLOWPUSH(FOLLOW_step_in_execution_order81);
                	        step(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleexecution_orderEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexecution_orderEx; /* Prevent compiler warnings */
    ruleexecution_orderEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end execution_order */

/**
 * $ANTLR start step
 * codegen.g:156:1: step : ^( IDENT IDENT ) ;
 */
static void
step(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:156:6: ( ^( IDENT IDENT ) )
        // codegen.g:156:8: ^( IDENT IDENT )
        {
             MATCHT(IDENT, &FOLLOW_IDENT_in_step96);
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

             MATCHT(IDENT, &FOLLOW_IDENT_in_step98);
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulestepEx; /* Prevent compiler warnings */
    rulestepEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end step */

/**
 * $ANTLR start common
 * codegen.g:159:1: common : ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) ) ;
 */
static void
common(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:159:8: ( ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) ) )
        // codegen.g:159:10: ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_common110);
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

             MATCHT(IDENT, &FOLLOW_IDENT_in_common113);
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {
                 TheModule = Common; 
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:159:50: ( param )?
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                        case PARAM:
                        	{
                        		alt3=1;
                        	}
                            break;
                    }

                    switch (alt3)
                    {
                	case 1:
                	    // codegen.g:159:50: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_common117);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                // codegen.g:159:57: ( global )?
                {
                    int alt4=2;
                    switch ( LA(1) )
                    {
                        case VARIABLE:
                        	{
                        		alt4=1;
                        	}
                            break;
                    }

                    switch (alt4)
                    {
                	case 1:
                	    // codegen.g:159:57: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_common120);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                // codegen.g:159:65: ( function )?
                {
                    int alt5=2;
                    switch ( LA(1) )
                    {
                        case FUNCTION:
                        	{
                        		alt5=1;
                        	}
                            break;
                    }

                    switch (alt5)
                    {
                	case 1:
                	    // codegen.g:159:65: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_common123);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulecommonEx; /* Prevent compiler warnings */
    rulecommonEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end common */

/**
 * $ANTLR start block
 * codegen.g:162:1: block[const char *part] : ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) ) ;
 */
static void
block(pcodegen ctx, const char *part)
{
    pANTLR3_BASE_TREE    IDENT1;

    /* Initialize rule variables
     */

    IDENT1       = NULL;

    {
        // codegen.g:163:2: ( ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) ) )
        // codegen.g:163:4: ^( BLOCK ^( IDENT ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block139);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            IDENT1 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_block142);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( BACKTRACKING==0 )
            {

                			Linker *linker = new Linker((const char*)(IDENT1->getText(IDENT1))->chars, (const char*)(IDENT1->getText(IDENT1))->chars, getGlobalContext());
                			linker->LinkInModule(Common);
                			TheModule = linker->getModule();
                			map<const char*, Variable, cmp_str> previous = (*(Vars.top()));
                			Vars.push(new map<const char*, Variable, cmp_str>(previous));
                			
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:169:6: ( param )?
                {
                    int alt6=2;
                    switch ( LA(1) )
                    {
                        case PARAM:
                        	{
                        		alt6=1;
                        	}
                            break;
                    }

                    switch (alt6)
                    {
                	case 1:
                	    // codegen.g:169:6: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_block146);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                // codegen.g:169:13: ( global )?
                {
                    int alt7=2;
                    switch ( LA(1) )
                    {
                        case VARIABLE:
                        	{
                        		alt7=1;
                        	}
                            break;
                    }

                    switch (alt7)
                    {
                	case 1:
                	    // codegen.g:169:13: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_block149);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                // codegen.g:169:21: ( function )?
                {
                    int alt8=2;
                    switch ( LA(1) )
                    {
                        case FUNCTION:
                        	{
                        		alt8=1;
                        	}
                            break;
                    }

                    switch (alt8)
                    {
                	case 1:
                	    // codegen.g:169:21: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_block152);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }



            if ( BACKTRACKING==0 )
            {
                 TheModule->dump(); delete Vars.top(); Vars.pop();
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end block */

/**
 * $ANTLR start param
 * codegen.g:172:1: param : ^( PARAM ( param_declaration )* ) ;
 */
static void
param(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:172:7: ( ^( PARAM ( param_declaration )* ) )
        // codegen.g:172:9: ^( PARAM ( param_declaration )* )
        {
             MATCHT(PARAM, &FOLLOW_PARAM_in_param169);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:172:17: ( param_declaration )*

                for (;;)
                {
                    int alt9=2;
                    switch ( LA(1) )
                    {
                    case IDENT:
                    	{
                    		alt9=1;
                    	}
                        break;

                    }

                    switch (alt9)
                    {
                	case 1:
                	    // codegen.g:172:18: param_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_param_declaration_in_param172);
                	        param_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleparamEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop9;	/* break out of the loop */
                	    break;
                    }
                }
                loop9: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end param */

/**
 * $ANTLR start global
 * codegen.g:175:1: global : ^( VARIABLE ( global_declaration )* ) ;
 */
static void
global(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:175:8: ( ^( VARIABLE ( global_declaration )* ) )
        // codegen.g:175:10: ^( VARIABLE ( global_declaration )* )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_global186);
            if  (HASEXCEPTION())
            {
                goto ruleglobalEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:175:21: ( global_declaration )*

                for (;;)
                {
                    int alt10=2;
                    switch ( LA(1) )
                    {
                    case IDENT:
                    	{
                    		alt10=1;
                    	}
                        break;

                    }

                    switch (alt10)
                    {
                	case 1:
                	    // codegen.g:175:22: global_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_global_declaration_in_global189);
                	        global_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleglobalEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop10;	/* break out of the loop */
                	    break;
                    }
                }
                loop10: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleglobalEx; /* Prevent compiler warnings */
    ruleglobalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end global */

/**
 * $ANTLR start function
 * codegen.g:178:1: function : ^( FUNCTION ( function_declaration )* ) ;
 */
static void
function(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:178:9: ( ^( FUNCTION ( function_declaration )* ) )
        // codegen.g:178:11: ^( FUNCTION ( function_declaration )* )
        {
             MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_function202);
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:178:22: ( function_declaration )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) )
                    {
                    case IDENT:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11)
                    {
                	case 1:
                	    // codegen.g:178:23: function_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_function_declaration_in_function205);
                	        function_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end function */

/**
 * $ANTLR start param_declaration
 * codegen.g:181:1: param_declaration returns [Value *value] : ^(par= IDENT type= type_declaration ( NUMBER |) ) ;
 */
static Value *
param_declaration(pcodegen ctx)
{
    Value * value;


    pANTLR3_BASE_TREE    par;
    pANTLR3_BASE_TREE    NUMBER2;
    NumberT * type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type NumberT *

    /* Initialize rule variables
     */

    par       = NULL;
    NUMBER2       = NULL;

    {
        // codegen.g:182:2: ( ^(par= IDENT type= type_declaration ( NUMBER |) ) )
        // codegen.g:182:4: ^(par= IDENT type= type_declaration ( NUMBER |) )
        {
            par = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_param_declaration226);
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            FOLLOWPUSH(FOLLOW_type_declaration_in_param_declaration230);
            type=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            // codegen.g:183:4: ( NUMBER |)
            {
                int alt12=2;
                switch ( LA(1) )
                {
                case NUMBER:
                	{
                		alt12=1;
                	}
                    break;
                case UP:
                	{
                		alt12=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return value;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleparam_declarationEx;

                }

                switch (alt12)
                {
            	case 1:
            	    // codegen.g:183:5: NUMBER
            	    {
            	        NUMBER2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_param_declaration236);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparam_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(
            	            type
            	            ->getBitWidth(), (const char*)(NUMBER2->getText(NUMBER2))->chars, 10));

            	        }


            	    }
            	    break;
            	case 2:
            	    // codegen.g:185:6: 
            	    {
            	        if ( BACKTRACKING==0 )
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(
            	            type
            	            ->getBitWidth(), 0));
            	             
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }



            if ( BACKTRACKING==0 )
            {

                		Variable parx;
                		parx.value = value
                ;
                		parx.type = type
                ;
                		parx.variable = false;

                		(*(Vars.top()))[(const char*) (par->getText(par))->chars] = parx;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparam_declarationEx; /* Prevent compiler warnings */
    ruleparam_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end param_declaration */

/**
 * $ANTLR start global_declaration
 * codegen.g:196:1: global_declaration returns [Value *value] : ^(var= IDENT type_declaration ( NUMBER )? ) ;
 */
static Value *
global_declaration(pcodegen ctx)
{
    Value * value;


    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration3;
    #undef	RETURN_TYPE_type_declaration3
    #define	RETURN_TYPE_type_declaration3 NumberT *

    /* Initialize rule variables
     */

    var       = NULL;

    {
        // codegen.g:197:2: ( ^(var= IDENT type_declaration ( NUMBER )? ) )
        // codegen.g:197:4: ^(var= IDENT type_declaration ( NUMBER )? )
        {
            var = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_global_declaration271);
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            FOLLOWPUSH(FOLLOW_type_declaration_in_global_declaration273);
            type_declaration3=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            if ( BACKTRACKING==0 )
            {
                 	value= new GlobalVariable(*TheModule, 
                type_declaration3
                ->getType(), false, GlobalVariable::ExternalLinkage, 0, (const char *) (var->getText(var))->chars, 0, true, 0);

                	
            }


            // codegen.g:199:4: ( NUMBER )?
            {
                int alt13=2;
                switch ( LA(1) )
                {
                    case NUMBER:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // codegen.g:199:5: NUMBER
            	    {
            	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_global_declaration279);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobal_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }



            if ( BACKTRACKING==0 )
            {

                		Variable varx;
                		varx.value = value
                ;
                		varx.type = type_declaration3
                ;
                		varx.variable = true;

                		(*(Vars.top()))[(const char*) (var->getText(var))->chars] = varx;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleglobal_declarationEx; /* Prevent compiler warnings */
    ruleglobal_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end global_declaration */

/**
 * $ANTLR start argument_declaration
 * codegen.g:210:1: argument_declaration returns [Arg *arg] : ( ( ^( IDENT type_declaration ) )=> ^(var= IDENT type_declaration ) | (var= IDENT ) );
 */
static Arg *
argument_declaration(pcodegen ctx)
{
    Arg * arg;


    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration4;
    #undef	RETURN_TYPE_type_declaration4
    #define	RETURN_TYPE_type_declaration4 NumberT *

    /* Initialize rule variables
     */

    var       = NULL;

    {
        {
            //  codegen.g:211:2: ( ( ^( IDENT type_declaration ) )=> ^(var= IDENT type_declaration ) | (var= IDENT ) )

            ANTLR3_UINT32 alt14;

            alt14=2;

            switch ( LA(1) )
            {
            case IDENT:
            	{
            		{
            		    int LA14_1 = LA(2);
            		    if ( (synpred1_codegen(ctx)) && (LA14_1 == DOWN))
            		    {
            		        alt14=1;
            		    }
            		    else if ( (LA14_1 == UP || LA14_1 == IDENT))
            		    {
            		        alt14=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return arg;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 1;


            		        goto ruleargument_declarationEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return arg;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleargument_declarationEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // codegen.g:211:4: ( ^( IDENT type_declaration ) )=> ^(var= IDENT type_declaration )
        	    {
        	        var = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_argument_declaration312);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }

        	        FOLLOWPUSH(FOLLOW_type_declaration_in_argument_declaration314);
        	        type_declaration4=type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	            		arg = new Arg();
        	            		arg
        	            ->id = (const char*)(var->getText(var))->chars;
        	            		
        	            arg
        	            ->type = type_declaration4
        	            ;
        	            		arg
        	            ->global_reference = false;
        	            		
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }



        	    }
        	    break;
        	case 2:
        	    // codegen.g:217:4: (var= IDENT )
        	    {
        	        // codegen.g:217:4: (var= IDENT )
        	        // codegen.g:217:5: var= IDENT
        	        {
        	            var = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_argument_declaration325);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleargument_declarationEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return arg;
        	            }


        	            if ( BACKTRACKING==0 )
        	            {

        	                		arg = new Arg();
        	                		arg
        	                ->id = (const char*)(var->getText(var))->chars;
        	                		
        	                arg
        	                ->type = (*(Vars.top()))[arg
        	                ->id].type;
        	                		arg
        	                ->value = (*(Vars.top()))[arg
        	                ->id].value;
        	                		arg
        	                ->global_reference = true;
        	                		
        	            }


        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleargument_declarationEx; /* Prevent compiler warnings */
    ruleargument_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return arg;
}
/* $ANTLR end argument_declaration */

/**
 * $ANTLR start type_declaration
 * codegen.g:226:1: type_declaration returns [NumberT *type] : ( group | interval );
 */
static NumberT *
type_declaration(pcodegen ctx)
{
    NumberT * type;


    NumberT * group5;
    #undef	RETURN_TYPE_group5
    #define	RETURN_TYPE_group5 NumberT *

    NumberT * interval6;
    #undef	RETURN_TYPE_interval6
    #define	RETURN_TYPE_interval6 NumberT *

    /* Initialize rule variables
     */

    {
        {
            //  codegen.g:227:2: ( group | interval )

            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) )
            {
            case 37:
            case 38:
            case 43:
            case 44:
            case 45:
            	{
            		alt15=1;
            	}
                break;
            case INTERVAL:
            	{
            		alt15=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return type;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruletype_declarationEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // codegen.g:227:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_type_declaration343);
        	        group5=group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            type= 
        	            group5
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:228:4: interval
        	    {
        	        FOLLOWPUSH(FOLLOW_interval_in_type_declaration350);
        	        interval6=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            type= 
        	            interval6
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletype_declarationEx; /* Prevent compiler warnings */
    ruletype_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return type;
}
/* $ANTLR end type_declaration */

/**
 * $ANTLR start function_declaration
 * codegen.g:231:1: function_declaration returns [Function *func, vector<Arg *> outs, vector<Arg *> inps] : ^( IDENT ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) ;
 */
static codegen_function_declaration_return
function_declaration(pcodegen ctx)
{
    codegen_function_declaration_return retval;


    pANTLR3_BASE_TREE    IDENT7;
    Arg * out;
    #undef	RETURN_TYPE_out
    #define	RETURN_TYPE_out Arg *

    Arg * inp;
    #undef	RETURN_TYPE_inp
    #define	RETURN_TYPE_inp Arg *

    /* Initialize rule variables
     */

    IDENT7       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // codegen.g:232:2: ( ^( IDENT ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) )
        // codegen.g:232:4: ^( IDENT ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? )
        {
            IDENT7 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_function_declaration368);
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

             MATCHT(OUTPUT, &FOLLOW_OUTPUT_in_function_declaration371);
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:232:21: ( 'Void' | (out= argument_declaration )* )
                {
                    int alt17=2;
                    switch ( LA(1) )
                    {
                    case 42:
                    	{
                    		alt17=1;
                    	}
                        break;
                    case UP:
                    case IDENT:
                    	{
                    		alt17=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }

                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 17;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;

                    }

                    switch (alt17)
                    {
                	case 1:
                	    // codegen.g:232:22: 'Void'
                	    {
                	         MATCHT(42, &FOLLOW_42_in_function_declaration374);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }


                	    }
                	    break;
                	case 2:
                	    // codegen.g:232:29: (out= argument_declaration )*
                	    {
                	        // codegen.g:232:29: (out= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt16=2;
                	            switch ( LA(1) )
                	            {
                	            case IDENT:
                	            	{
                	            		alt16=1;
                	            	}
                	                break;

                	            }

                	            switch (alt16)
                	            {
                	        	case 1:
                	        	    // codegen.g:232:30: out= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration379);
                	        	        out=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }


                	        	        if ( BACKTRACKING==0 )
                	        	        {
                	        	             retval.outs
                	        	            .push_back(out
                	        	            ); 
                	        	        }


                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop16;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop16: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

            }


             MATCHT(INP, &FOLLOW_INP_in_function_declaration392);
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:233:10: ( 'Void' | (inp= argument_declaration )* )
                {
                    int alt19=2;
                    switch ( LA(1) )
                    {
                    case 42:
                    	{
                    		alt19=1;
                    	}
                        break;
                    case UP:
                    case IDENT:
                    	{
                    		alt19=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }

                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;

                    }

                    switch (alt19)
                    {
                	case 1:
                	    // codegen.g:233:11: 'Void'
                	    {
                	         MATCHT(42, &FOLLOW_42_in_function_declaration395);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }


                	    }
                	    break;
                	case 2:
                	    // codegen.g:233:18: (inp= argument_declaration )*
                	    {
                	        // codegen.g:233:18: (inp= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt18=2;
                	            switch ( LA(1) )
                	            {
                	            case IDENT:
                	            	{
                	            		alt18=1;
                	            	}
                	                break;

                	            }

                	            switch (alt18)
                	            {
                	        	case 1:
                	        	    // codegen.g:233:19: inp= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration400);
                	        	        inp=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }


                	        	        if ( BACKTRACKING==0 )
                	        	        {
                	        	             retval.inps
                	        	            .push_back(inp
                	        	            ); 
                	        	        }


                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop18;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop18: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

            }


            if ( BACKTRACKING==0 )
            {

                			vector<Type *> Inps;
                			
                			for(vector<Arg *>::iterator i = retval.inps
                .begin(); i != retval.inps
                .end(); i++) {
                				Inps.push_back((*i)->type->getType());
                			}
                			
                			vector<Type *> Outs;
                			
                			for(vector<Arg *>::iterator i = retval.outs
                .begin(); i != retval.outs
                .end(); i++) {
                				Outs.push_back((*i)->type->getType());
                			}

                			FunctionType *FT;
                			
                			if(retval.outs
                .size() == 0) {
                				FT = FunctionType::get(Type::getVoidTy(getGlobalContext()), Inps, false);
                			} else {
                				FT = FunctionType::get(StructType::create(getGlobalContext(), Outs, "rty"), Inps, false);
                			}
                		
                			retval.func= Function::Create(FT, Function::ExternalLinkage, (const char*) (IDENT7->getText(IDENT7))->chars, TheModule);

                			
                			BasicBlock *entry_block = BasicBlock::Create(getGlobalContext(), "entry", retval.func
                );
                			
                			Builder.SetInsertPoint(entry_block);
                			
                			for(vector<Arg*>::iterator def = retval.outs
                .begin(); def != retval.outs
                .end(); def++) {
                				if(!(*def)->global_reference) {
                					Variable varx;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					(*(Vars.top()))[(*def)->id] = varx;
                				}
                			}
                			
                			vector<Arg*>::iterator def = retval.inps
                .begin();
                			
                			for(Function::arg_iterator arg = retval.func
                ->arg_begin(); arg != retval.func
                ->arg_end(); arg++, def++) {
                				if(!(*def)->global_reference)
                				{
                					arg->setName((*def)->id);
                				
                					Variable varx;
                					
                					varx.value = arg;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					(*(Vars.top()))[(*def)->id] = varx;
                				} else {
                					arg->setName((*def)->id);
                				
                					Builder.CreateStore(arg, (*def)->value);
                				}
                			}
                		
            }


            // codegen.g:292:3: ( body )?
            {
                int alt20=2;
                switch ( LA(1) )
                {
                    case BODY:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // codegen.g:292:3: body
            	    {
            	        FOLLOWPUSH(FOLLOW_body_in_function_declaration416);
            	        body(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }



            if ( BACKTRACKING==0 )
            {
                	
                			Value **values = new Value*[retval.outs
                .size()];
                			
                			int pos = 0;
                		
                			for(vector<Arg *>::iterator i = retval.outs
                .begin(); i != retval.outs
                .end(); i++) {
                				Variable varx = (*(Vars.top()))[(*i)->id];				
                				
                				if(varx.variable)
                					values[pos++] = Builder.CreateLoad(varx.value, retval.outs
                [0]->id);
                				else
                					values[pos++] = varx.value;
                			}
                			
                			if(retval.outs
                .size() > 0) {
                				Builder.CreateAggregateRet(values, retval.outs
                .size());
                			} else {
                				Builder.CreateRetVoid();			
                			}
                			
                			delete[] values;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunction_declarationEx; /* Prevent compiler warnings */
    rulefunction_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end function_declaration */

/**
 * $ANTLR start body
 * codegen.g:317:1: body : ^( BODY ( statement )* ) ;
 */
static void
body(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        // codegen.g:317:6: ( ^( BODY ( statement )* ) )
        // codegen.g:317:8: ^( BODY ( statement )* )
        {
             MATCHT(BODY, &FOLLOW_BODY_in_body433);
            if  (HASEXCEPTION())
            {
                goto rulebodyEx;
            }
            if (HASFAILED())
            {
                return ;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:317:15: ( statement )*

                for (;;)
                {
                    int alt21=2;
                    switch ( LA(1) )
                    {
                    case 28:
                    case 32:
                    case 39:
                    case 40:
                    case 41:
                    	{
                    		alt21=1;
                    	}
                        break;

                    }

                    switch (alt21)
                    {
                	case 1:
                	    // codegen.g:317:15: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_body435);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulebodyEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop21;	/* break out of the loop */
                	    break;
                    }
                }
                loop21: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end body */

/**
 * $ANTLR start statement
 * codegen.g:320:1: statement : ( assignment | function_call[\"call\"] );
 */
static void
statement(pcodegen ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  codegen.g:321:2: ( assignment | function_call[\"call\"] )

            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) )
            {
            case 28:
            	{
            		alt22=1;
            	}
                break;
            case 32:
            case 39:
            case 40:
            case 41:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // codegen.g:321:4: assignment
        	    {
        	        FOLLOWPUSH(FOLLOW_assignment_in_statement449);
        	        assignment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:322:4: function_call[\"call\"]
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_statement454);
        	        function_call(ctx, "call");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start assignment
 * codegen.g:325:1: assignment returns [Value *value] : ^( ':=' IDENT expr[(const char*)$IDENT.text->chars] ) ;
 */
static Value *
assignment(pcodegen ctx)
{
    Value * value;


    pANTLR3_BASE_TREE    IDENT8;
    codegen_expr_return expr9;
    #undef	RETURN_TYPE_expr9
    #define	RETURN_TYPE_expr9 codegen_expr_return

    /* Initialize rule variables
     */

    IDENT8       = NULL;

    {
        // codegen.g:326:2: ( ^( ':=' IDENT expr[(const char*)$IDENT.text->chars] ) )
        // codegen.g:326:4: ^( ':=' IDENT expr[(const char*)$IDENT.text->chars] )
        {
             MATCHT(28, &FOLLOW_28_in_assignment471);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            IDENT8 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_assignment473);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            FOLLOWPUSH(FOLLOW_expr_in_assignment475);
            expr9=expr(ctx, (const char*)(IDENT8->getText(IDENT8))->chars);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }



            if ( BACKTRACKING==0 )
            {
                			
                			const char *id = (const char*) (IDENT8->getText(IDENT8))->chars;
                		
                			if((*(Vars.top())).find(id) == (*(Vars.top())).end()) {
                				Variable varx;
                				varx.variable = false;
                				varx.type = 
                expr9.type
                ;
                				(*(Vars.top()))[id] = varx;
                			}
                		
                			Variable dest = (*(Vars.top()))[id];
                			
                			if(!dest.variable) {
                				dest.value = expr9.value
                ;
                				
                				(*(Vars.top()))[id] = dest;
                			} else {
                				value= Builder.CreateStore(
                expr9.value
                , dest.value);
                			
                			}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end assignment */

/**
 * $ANTLR start concat
 * codegen.g:349:1: concat[const char *id] returns [Value *value] : ( IDENT | hash[$id] | ^( '||' concat[$id] concat[$id] ) );
 */
static Value *
concat(pcodegen ctx, const char *id)
{
    Value * value;


    /* Initialize rule variables
     */

    {
        {
            //  codegen.g:350:2: ( IDENT | hash[$id] | ^( '||' concat[$id] concat[$id] ) )

            ANTLR3_UINT32 alt23;

            alt23=3;

            switch ( LA(1) )
            {
            case IDENT:
            	{
            		alt23=1;
            	}
                break;
            case 40:
            	{
            		alt23=2;
            	}
                break;
            case 50:
            	{
            		alt23=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return value;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto ruleconcatEx;

            }

            switch (alt23)
            {
        	case 1:
        	    // codegen.g:350:4: IDENT
        	    {
        	         MATCHT(IDENT, &FOLLOW_IDENT_in_concat500);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:351:4: hash[$id]
        	    {
        	        FOLLOWPUSH(FOLLOW_hash_in_concat505);
        	        hash(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	    }
        	    break;
        	case 3:
        	    // codegen.g:352:4: ^( '||' concat[$id] concat[$id] )
        	    {
        	         MATCHT(50, &FOLLOW_50_in_concat512);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	        FOLLOWPUSH(FOLLOW_concat_in_concat514);
        	        concat(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	        FOLLOWPUSH(FOLLOW_concat_in_concat517);
        	        concat(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconcatEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleconcatEx; /* Prevent compiler warnings */
    ruleconcatEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end concat */

/**
 * $ANTLR start hash
 * codegen.g:355:1: hash[const char *id] returns [Value *value, NumberT *type] : ^( 'SHA256' concat[$id] ) ;
 */
static codegen_hash_return
hash(pcodegen ctx, const char *id)
{
    codegen_hash_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // codegen.g:356:2: ( ^( 'SHA256' concat[$id] ) )
        // codegen.g:356:4: ^( 'SHA256' concat[$id] )
        {
             MATCHT(40, &FOLLOW_40_in_hash538);
            if  (HASEXCEPTION())
            {
                goto rulehashEx;
            }
            if (HASFAILED())
            {
                return retval;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulehashEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            FOLLOWPUSH(FOLLOW_concat_in_hash540);
            concat(ctx, id);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehashEx;
            }
            if (HASFAILED())
            {
                return retval;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulehashEx;
            }
            if (HASFAILED())
            {
                return retval;
            }



            if ( BACKTRACKING==0 )
            {

                			retval.value= ConstantInt::get(getGlobalContext(), APInt(256, 0));

                			retval.type= new NumberT(256);

                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulehashEx; /* Prevent compiler warnings */
    rulehashEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end hash */

/**
 * $ANTLR start function_call
 * codegen.g:363:1: function_call[const char *id] returns [Value *value, NumberT *type] : ( ^( 'Random' type_declaration ) | hash[$id] | ^( 'CheckMembership' argument type_declaration ) | ^( 'Verify' expr[\"verify\"] ) );
 */
static codegen_function_call_return
function_call(pcodegen ctx, const char *id)
{
    codegen_function_call_return retval;


    NumberT * type_declaration10;
    #undef	RETURN_TYPE_type_declaration10
    #define	RETURN_TYPE_type_declaration10 NumberT *

    codegen_hash_return hash11;
    #undef	RETURN_TYPE_hash11
    #define	RETURN_TYPE_hash11 codegen_hash_return

    Value * argument12;
    #undef	RETURN_TYPE_argument12
    #define	RETURN_TYPE_argument12 Value *

    codegen_expr_return expr13;
    #undef	RETURN_TYPE_expr13
    #define	RETURN_TYPE_expr13 codegen_expr_return

    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  codegen.g:364:2: ( ^( 'Random' type_declaration ) | hash[$id] | ^( 'CheckMembership' argument type_declaration ) | ^( 'Verify' expr[\"verify\"] ) )

            ANTLR3_UINT32 alt24;

            alt24=4;

            switch ( LA(1) )
            {
            case 39:
            	{
            		alt24=1;
            	}
                break;
            case 40:
            	{
            		alt24=2;
            	}
                break;
            case 32:
            	{
            		alt24=3;
            	}
                break;
            case 41:
            	{
            		alt24=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulefunction_callEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // codegen.g:364:4: ^( 'Random' type_declaration )
        	    {
        	         MATCHT(39, &FOLLOW_39_in_function_call565);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_type_declaration_in_function_call567);
        	        type_declaration10=type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {

        	            			retval.type= 
        	            type_declaration10
        	            ;
        	            			
        	            		
        	            			vector<Value*> args;
        	            			vector<Type*> types;
        	            			
        	            			types.push_back(retval.type
        	            ->getType());
        	            			types.push_back(retval.type
        	            ->getType());

        	            			Function *function = Intrinsic::getDeclaration(TheModule, Intrinsic::random, types);
        	            			
        	            			if(GroupT *group_t = dynamic_cast<GroupT*>(retval.type
        	            ))
        	            				args.push_back(ConstantInt::get(getGlobalContext(), group_t->getModulus()));
        	            			else
        	            				args.push_back(ConstantInt::get(getGlobalContext(), APInt(retval.type
        	            ->getBitWidth(), 0)));

        	            			retval.value= Builder.CreateCall(function, args, id);
        	            			
        	            		
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:383:4: hash[$id]
        	    {
        	        FOLLOWPUSH(FOLLOW_hash_in_function_call577);
        	        hash11=hash(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	            			retval.value= 
        	            hash11.value
        	            ;

        	            			retval.type= 
        	            hash11.type
        	            ;

        	            		
        	        }


        	    }
        	    break;
        	case 3:
        	    // codegen.g:388:4: ^( 'CheckMembership' argument type_declaration )
        	    {
        	         MATCHT(32, &FOLLOW_32_in_function_call588);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_argument_in_function_call590);
        	        argument12=argument(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_type_declaration_in_function_call592);
        	        type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {

        	            			Function *CalleeF = TheModule->getFunction("CheckMembership");

        	            			vector<Value *> ArgsV;
        	            			
        	            			ArgsV.push_back(argument12
        	            );
        	            			
        	            			retval.value= Builder.CreateCall(CalleeF, ArgsV, id);

        	            			
        	            			retval.type= new GroupT(APInt(1024,0));
        	            			
        	            		
        	        }


        	    }
        	    break;
        	case 4:
        	    // codegen.g:400:4: ^( 'Verify' expr[\"verify\"] )
        	    {
        	         MATCHT(41, &FOLLOW_41_in_function_call603);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_function_call605);
        	        expr13=expr(ctx, "verify");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {

        	            			Function *CalleeF = TheModule->getFunction("Verify");
        	            			
        	            			vector<Value *> ArgsV;
        	            			
        	            			ArgsV.push_back(expr13.value
        	            );
        	            			
        	            			retval.value= Builder.CreateCall(CalleeF, ArgsV, id);

        	            			
        	            			retval.type= new GroupT(APInt(1024,0));
        	            			
        	            		
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start argument
 * codegen.g:414:1: argument returns [Value *value] : ( expr[\"arg\"] | group );
 */
static Value *
argument(pcodegen ctx)
{
    Value * value;


    codegen_expr_return expr14;
    #undef	RETURN_TYPE_expr14
    #define	RETURN_TYPE_expr14 codegen_expr_return

    /* Initialize rule variables
     */

    {
        {
            //  codegen.g:415:2: ( expr[\"arg\"] | group )

            ANTLR3_UINT32 alt25;

            alt25=2;

            switch ( LA(1) )
            {
            case IDENT:
            case NUMBER:
            case 19:
            case 22:
            case 23:
            case 25:
            case 31:
            case 32:
            case 39:
            case 40:
            case 41:
            case 48:
            	{
            		alt25=1;
            	}
                break;
            case 37:
            case 38:
            case 43:
            case 44:
            case 45:
            	{
            		alt25=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return value;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // codegen.g:415:4: expr[\"arg\"]
        	    {
        	        FOLLOWPUSH(FOLLOW_expr_in_argument628);
        	        expr14=expr(ctx, "arg");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             value= 
        	            expr14.value
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:416:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_argument636);
        	        group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end argument */

/**
 * $ANTLR start group
 * codegen.g:419:1: group returns [NumberT *type] : ( 'Z' | ^( 'Prime' expr[\"group\"] ) | ^( 'Int' expr[\"group\"] ) | ^( 'Zmod+' IDENT ) | ^( 'Zmod*' IDENT ) );
 */
static NumberT *
group(pcodegen ctx)
{
    NumberT * type;


    pANTLR3_BASE_TREE    IDENT17;
    pANTLR3_BASE_TREE    IDENT18;
    codegen_expr_return expr15;
    #undef	RETURN_TYPE_expr15
    #define	RETURN_TYPE_expr15 codegen_expr_return

    codegen_expr_return expr16;
    #undef	RETURN_TYPE_expr16
    #define	RETURN_TYPE_expr16 codegen_expr_return

    /* Initialize rule variables
     */

    IDENT17       = NULL;
    IDENT18       = NULL;

    {
        {
            //  codegen.g:420:2: ( 'Z' | ^( 'Prime' expr[\"group\"] ) | ^( 'Int' expr[\"group\"] ) | ^( 'Zmod+' IDENT ) | ^( 'Zmod*' IDENT ) )

            ANTLR3_UINT32 alt26;

            alt26=5;

            switch ( LA(1) )
            {
            case 43:
            	{
            		alt26=1;
            	}
                break;
            case 38:
            	{
            		alt26=2;
            	}
                break;
            case 37:
            	{
            		alt26=3;
            	}
                break;
            case 45:
            	{
            		alt26=4;
            	}
                break;
            case 44:
            	{
            		alt26=5;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return type;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto rulegroupEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // codegen.g:420:4: 'Z'
        	    {
        	         MATCHT(43, &FOLLOW_43_in_group651);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	             type= new NumberT(32);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:421:4: ^( 'Prime' expr[\"group\"] )
        	    {
        	         MATCHT(38, &FOLLOW_38_in_group659);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_group661);
        	        expr15=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	             type= new NumberT(static_cast<ConstantInt*>(
        	            expr15.value
        	            )->getValue().getLimitedValue(1024));
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // codegen.g:422:4: ^( 'Int' expr[\"group\"] )
        	    {
        	         MATCHT(37, &FOLLOW_37_in_group671);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_group673);
        	        expr16=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	             type= new NumberT(static_cast<ConstantInt*>(
        	            expr16.value
        	            )->getValue().getLimitedValue(1024));
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // codegen.g:423:4: ^( 'Zmod+' IDENT )
        	    {
        	         MATCHT(45, &FOLLOW_45_in_group683);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        IDENT17 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_group685);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	             type= new GroupT(static_cast<ConstantInt*>((*Vars.top())[(const char*)(IDENT17->getText(IDENT17))->chars].value)->getValue());
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // codegen.g:424:4: ^( 'Zmod*' IDENT )
        	    {
        	         MATCHT(44, &FOLLOW_44_in_group694);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        IDENT18 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_group696);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	             type= new GroupT(static_cast<ConstantInt*>((*Vars.top())[(const char*)(IDENT18->getText(IDENT18))->chars].value)->getValue());
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulegroupEx; /* Prevent compiler warnings */
    rulegroupEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return type;
}
/* $ANTLR end group */

/**
 * $ANTLR start alias
 * codegen.g:427:1: alias returns [NumberT *type] : ^( '=' IDENT ( group | interval ) ) ;
 */
static NumberT *
alias(pcodegen ctx)
{
    NumberT * type;


    pANTLR3_BASE_TREE    IDENT21;
    NumberT * group19;
    #undef	RETURN_TYPE_group19
    #define	RETURN_TYPE_group19 NumberT *

    NumberT * interval20;
    #undef	RETURN_TYPE_interval20
    #define	RETURN_TYPE_interval20 NumberT *

    /* Initialize rule variables
     */

    IDENT21       = NULL;

    {
        // codegen.g:428:2: ( ^( '=' IDENT ( group | interval ) ) )
        // codegen.g:428:4: ^( '=' IDENT ( group | interval ) )
        {
             MATCHT(30, &FOLLOW_30_in_alias715);
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            IDENT21 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_alias717);
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }


            // codegen.g:428:16: ( group | interval )
            {
                int alt27=2;
                switch ( LA(1) )
                {
                case 37:
                case 38:
                case 43:
                case 44:
                case 45:
                	{
                		alt27=1;
                	}
                    break;
                case INTERVAL:
                	{
                		alt27=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return type;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 27;
                    EXCEPTION->state        = 0;


                    goto rulealiasEx;

                }

                switch (alt27)
                {
            	case 1:
            	    // codegen.g:428:17: group
            	    {
            	        FOLLOWPUSH(FOLLOW_group_in_alias720);
            	        group19=group(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	            type=
            	            group19
            	            ;
            	             
            	        }


            	    }
            	    break;
            	case 2:
            	    // codegen.g:428:47: interval
            	    {
            	        FOLLOWPUSH(FOLLOW_interval_in_alias726);
            	        interval20=interval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	            type=
            	            interval20
            	            ;
            	             
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }



            if ( BACKTRACKING==0 )
            {

                			Types[(const char*)(IDENT21->getText(IDENT21))->chars] = 
                type
                ;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return type;
}
/* $ANTLR end alias */

/**
 * $ANTLR start interval
 * codegen.g:434:1: interval returns [NumberT *type] : ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) ;
 */
static NumberT *
interval(pcodegen ctx)
{
    NumberT * type;


    /* Initialize rule variables
     */

    {
        // codegen.g:435:2: ( ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) )
        // codegen.g:435:3: ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] )
        {
             MATCHT(INTERVAL, &FOLLOW_INTERVAL_in_interval750);
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            FOLLOWPUSH(FOLLOW_expr_in_interval752);
            expr(ctx, "lhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }


            FOLLOWPUSH(FOLLOW_expr_in_interval755);
            expr(ctx, "rhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }



            if ( BACKTRACKING==0 )
            {
                type= new GroupT(APInt(32, 0));
                 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintervalEx; /* Prevent compiler warnings */
    ruleintervalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return type;
}
/* $ANTLR end interval */

/**
 * $ANTLR start expr
 * codegen.g:438:1: expr[const char *id] returns [Value *value, NumberT *type] : ( ( '-' val= expr[$id] ) | ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call[$id] | IDENT | NUMBER );
 */
static codegen_expr_return
expr(pcodegen ctx, const char *id)
{
    codegen_expr_return retval;


    pANTLR3_BASE_TREE    IDENT23;
    pANTLR3_BASE_TREE    NUMBER24;
    codegen_expr_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val codegen_expr_return

    codegen_expr_return lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs codegen_expr_return

    codegen_expr_return rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs codegen_expr_return

    codegen_function_call_return function_call22;
    #undef	RETURN_TYPE_function_call22
    #define	RETURN_TYPE_function_call22 codegen_function_call_return

    /* Initialize rule variables
     */

    IDENT23       = NULL;
    NUMBER24       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  codegen.g:439:2: ( ( '-' val= expr[$id] ) | ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call[$id] | IDENT | NUMBER )

            ANTLR3_UINT32 alt28;

            alt28=10;

            switch ( LA(1) )
            {
            case 25:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				alt28=3;
            			}
            		    break;
            		case IDENT:
            		case NUMBER:
            		case 19:
            		case 22:
            		case 23:
            		case 25:
            		case 31:
            		case 32:
            		case 39:
            		case 40:
            		case 41:
            		case 48:
            			{
            				alt28=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 28;
            		    EXCEPTION->state        = 1;


            		    goto ruleexprEx;

            		}

            	}
                break;
            case 23:
            	{
            		alt28=2;
            	}
                break;
            case 22:
            	{
            		alt28=4;
            	}
                break;
            case 48:
            	{
            		alt28=5;
            	}
                break;
            case 31:
            	{
            		alt28=6;
            	}
                break;
            case 19:
            	{
            		alt28=7;
            	}
                break;
            case 32:
            case 39:
            case 40:
            case 41:
            	{
            		alt28=8;
            	}
                break;
            case IDENT:
            	{
            		alt28=9;
            	}
                break;
            case NUMBER:
            	{
            		alt28=10;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleexprEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // codegen.g:439:4: ( '-' val= expr[$id] )
        	    {
        	        // codegen.g:439:4: ( '-' val= expr[$id] )
        	        // codegen.g:439:5: '-' val= expr[$id]
        	        {
        	             MATCHT(25, &FOLLOW_25_in_expr777);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexprEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }


        	            FOLLOWPUSH(FOLLOW_expr_in_expr781);
        	            val=expr(ctx, id);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexprEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }


        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= 
        	            val.type
        	            ;
        	             retval.value= 
        	            retval.type
        	            ->createNeg(id, 
        	            val.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // codegen.g:440:4: ^( '+' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(23, &FOLLOW_23_in_expr791);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr795);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr800);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= *
        	            lhs.type
        	             + *rhs.type
        	            ;
        	             retval.value= 
        	            retval.type
        	            ->createAdd(id, 
        	            lhs.value
        	            , rhs.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // codegen.g:441:4: ^( '-' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(25, &FOLLOW_25_in_expr810);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr814);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr819);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= *
        	            lhs.type
        	             - *rhs.type
        	            ;
        	             retval.value= 
        	            retval.type
        	            ->createSub(id, 
        	            lhs.value
        	            , rhs.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // codegen.g:442:4: ^( '*' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(22, &FOLLOW_22_in_expr829);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr833);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr838);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= *
        	            lhs.type
        	             * *rhs.type
        	            ;
        	             retval.value= 
        	            retval.type
        	            ->createMul(id, 
        	            lhs.value
        	            , rhs.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // codegen.g:443:4: ^( '^' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(48, &FOLLOW_48_in_expr848);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr852);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr857);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= *
        	            lhs.type
        	             ^ *rhs.type
        	            ;
        	             retval.value= 
        	            retval.type
        	            ->createExp(id, 
        	            lhs.value
        	            , rhs.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 6:
        	    // codegen.g:444:4: ^( '==' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(31, &FOLLOW_31_in_expr867);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr871);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr876);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.value= Builder.CreateICmpEQ(
        	            lhs.value
        	            , rhs.value
        	            , id);

        	        }


        	    }
        	    break;
        	case 7:
        	    // codegen.g:445:4: ^( '!=' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(19, &FOLLOW_19_in_expr886);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        FOLLOWPUSH(FOLLOW_expr_in_expr890);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_expr_in_expr895);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }



        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.value= Builder.CreateICmpNE(
        	            lhs.value
        	            , rhs.value
        	            , id);

        	        }


        	    }
        	    break;
        	case 8:
        	    // codegen.g:446:4: function_call[$id]
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_expr904);
        	        function_call22=function_call(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= 
        	            function_call22.type
        	            ;
        	             retval.value= 
        	            function_call22.value
        	            ;

        	        }


        	    }
        	    break;
        	case 9:
        	    // codegen.g:447:4: IDENT
        	    {
        	        IDENT23 = (pANTLR3_BASE_TREE) MATCHT(IDENT, &FOLLOW_IDENT_in_expr912);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {

        	            			Variable varx = (*(Vars.top()))[(const char *) (IDENT23->getText(IDENT23))->chars];
        	            			
        	            retval.type= varx.type;

        	            			if(!varx.variable) {
        	            				retval.value= varx.value;

        	            			} else {
        	            				retval.value= Builder.CreateLoad(varx.value, (const char*) (IDENT23->getText(IDENT23))->chars);

        	            			}
        	            		
        	        }


        	    }
        	    break;
        	case 10:
        	    // codegen.g:457:4: NUMBER
        	    {
        	        NUMBER24 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expr921);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            retval.type= new NumberT(1024);
        	             retval.value= ConstantInt::get(getGlobalContext(), APInt(1024, (const char*) (NUMBER24->getText(NUMBER24))->chars, 10));

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expr */

// $ANTLR start synpred1_codegen
static void synpred1_codegen_fragment(pcodegen ctx )
{
    // codegen.g:211:4: ( ^( IDENT type_declaration ) )
    // codegen.g:211:5: ^( IDENT type_declaration )
    {
         MATCHT(IDENT, &FOLLOW_IDENT_in_synpred1_codegen302);
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        FOLLOWPUSH(FOLLOW_type_declaration_in_synpred1_codegen304);
        type_declaration(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        MATCHT(ANTLR3_TOKEN_UP, NULL);
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

// This is where rules clean up and exit
//
goto rulesynpred1_codegenEx; /* Prevent compiler warnings */
rulesynpred1_codegenEx: ;

}
// $ANTLR end synpred1_codegen
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_codegen(pcodegen ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_codegen_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
