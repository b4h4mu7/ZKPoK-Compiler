/** \file
 *  This C source file was generated by $ANTLR version 3.2 Fedora release 15 (Rawhide) Tue Feb  8 02:02:23 UTC 2011
 *
 *     -  From the grammar source file : codegen.g
 *     -                            On : 2012-02-20 19:36:29
 *     -           for the tree parser : codegenTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "codegen.h"
	
	struct cmp_str
	{
		bool operator()(const char *a, const char *b)
		{
			return strcmp(a, b) < 0;
		}
	};
	
	static Module *Common = new Module("Common", getGlobalContext());
	static Module *TheModule;
	static IRBuilder<> Builder(getGlobalContext());
	static map<const char*, Variable, cmp_str> Vars;
	static map<const char*, NumberT*, cmp_str> Types;
				
	Value* operator_call(const char *name, const char *fname, Value *a, Value *b, Value *mod)
	{
		Function *function = TheModule->getFunction(fname);
	
		vector<Value*> args;
		
		args.push_back(a);
		args.push_back(b);
		args.push_back(mod);
		
		return Builder.CreateCall(function, args, name);
	}
	
	NumberT *operator+(NumberT *lhs, NumberT &rhs) { return lhs; }
	NumberT *operator-(NumberT *lhs, NumberT &rhs) { return lhs; }
	NumberT *operator*(NumberT *lhs, NumberT &rhs) { return lhs; }
	NumberT *operator^(NumberT *lhs, NumberT &rhs) { return lhs; }	

	void init_common() 
	{
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(0, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "Random", Common);		
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(0, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "CheckMembership", Common);
		
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modadd1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modsub1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modmul1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modexp1024", Common);
		
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(1, Type::getInt1Ty(getGlobalContext())),
				false),
			Function::ExternalLinkage, "Verify", Common);
	}

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pcodegen_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcodegen_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pcodegen_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pcodegen_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   codegenTokenNames[39+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "INTERVAL",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PROOF",
        (pANTLR3_UINT8) "ORDER",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "INP",
        (pANTLR3_UINT8) "OUTPUT",
        (pANTLR3_UINT8) "BODY",
        (pANTLR3_UINT8) "VARIABLE",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "GROUP",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'ExecutionOrder'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'Def'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'Void'",
        (pANTLR3_UINT8) "'IfKnown'",
        (pANTLR3_UINT8) "'Else'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	proof    (pcodegen ctx, const char *part);
static void	execution_order    (pcodegen ctx);
static void	step    (pcodegen ctx);
static void	common    (pcodegen ctx);
static void	block    (pcodegen ctx, const char *part);
static void	param    (pcodegen ctx);
static void	global    (pcodegen ctx);
static void	function    (pcodegen ctx);
static Value *	param_declaration    (pcodegen ctx);
static Value *	global_declaration    (pcodegen ctx);
static Arg *	argument_declaration    (pcodegen ctx);
static NumberT *	type_declaration    (pcodegen ctx);
static codegen_function_declaration_return	function_declaration    (pcodegen ctx);
static void	body    (pcodegen ctx);
static void	statement    (pcodegen ctx);
static Value *	assignment    (pcodegen ctx);
static codegen_function_call_return	function_call    (pcodegen ctx);
static Value *	argument    (pcodegen ctx);
static NumberT *	group    (pcodegen ctx);
static NumberT *	alias    (pcodegen ctx);
static NumberT *	interval    (pcodegen ctx);
static codegen_expr_return	expr    (pcodegen ctx, const char *id);
static ANTLR3_BOOLEAN	synpred1_codegen    (pcodegen ctx);
static void	codegenFree(pcodegen ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "codegen.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return codegenNewSSD(instream, NULL);
}

/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcodegen ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pcodegen) ANTLR3_CALLOC(1, sizeof(codegen));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in codegen.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our codegen interface
     */
    ctx->proof	= proof;
    ctx->execution_order	= execution_order;
    ctx->step	= step;
    ctx->common	= common;
    ctx->block	= block;
    ctx->param	= param;
    ctx->global	= global;
    ctx->function	= function;
    ctx->param_declaration	= param_declaration;
    ctx->global_declaration	= global_declaration;
    ctx->argument_declaration	= argument_declaration;
    ctx->type_declaration	= type_declaration;
    ctx->function_declaration	= function_declaration;
    ctx->body	= body;
    ctx->statement	= statement;
    ctx->assignment	= assignment;
    ctx->function_call	= function_call;
    ctx->argument	= argument;
    ctx->group	= group;
    ctx->alias	= alias;
    ctx->interval	= interval;
    ctx->expr	= expr;
    ctx->synpred1_codegen	= synpred1_codegen;
    ctx->free			= codegenFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = codegenTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 codegenFree(pcodegen ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return codegenTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROOF_in_proof51  */
static	ANTLR3_BITWORD FOLLOW_PROOF_in_proof51_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PROOF_in_proof51	= { FOLLOW_PROOF_in_proof51_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_execution_order_in_proof53  */
static	ANTLR3_BITWORD FOLLOW_execution_order_in_proof53_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_execution_order_in_proof53	= { FOLLOW_execution_order_in_proof53_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_in_proof55  */
static	ANTLR3_BITWORD FOLLOW_common_in_proof55_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_common_in_proof55	= { FOLLOW_common_in_proof55_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_proof58  */
static	ANTLR3_BITWORD FOLLOW_block_in_proof58_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_proof58	= { FOLLOW_block_in_proof58_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ORDER_in_execution_order74  */
static	ANTLR3_BITWORD FOLLOW_ORDER_in_execution_order74_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ORDER_in_execution_order74	= { FOLLOW_ORDER_in_execution_order74_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_step_in_execution_order77  */
static	ANTLR3_BITWORD FOLLOW_step_in_execution_order77_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_step_in_execution_order77	= { FOLLOW_step_in_execution_order77_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_step92  */
static	ANTLR3_BITWORD FOLLOW_ID_in_step92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_step92	= { FOLLOW_ID_in_step92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_step94  */
static	ANTLR3_BITWORD FOLLOW_ID_in_step94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_step94	= { FOLLOW_ID_in_step94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_common106  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_common106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_common106	= { FOLLOW_BLOCK_in_common106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_common109  */
static	ANTLR3_BITWORD FOLLOW_ID_in_common109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_common109	= { FOLLOW_ID_in_common109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_common113  */
static	ANTLR3_BITWORD FOLLOW_param_in_common113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_common113	= { FOLLOW_param_in_common113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_common116  */
static	ANTLR3_BITWORD FOLLOW_global_in_common116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_common116	= { FOLLOW_global_in_common116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_common119  */
static	ANTLR3_BITWORD FOLLOW_function_in_common119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_common119	= { FOLLOW_function_in_common119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block135  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block135	= { FOLLOW_BLOCK_in_block135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_block138  */
static	ANTLR3_BITWORD FOLLOW_ID_in_block138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_block138	= { FOLLOW_ID_in_block138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_block142  */
static	ANTLR3_BITWORD FOLLOW_param_in_block142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_block142	= { FOLLOW_param_in_block142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_block145  */
static	ANTLR3_BITWORD FOLLOW_global_in_block145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_block145	= { FOLLOW_global_in_block145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_block148  */
static	ANTLR3_BITWORD FOLLOW_function_in_block148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_block148	= { FOLLOW_function_in_block148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAM_in_param165  */
static	ANTLR3_BITWORD FOLLOW_PARAM_in_param165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAM_in_param165	= { FOLLOW_PARAM_in_param165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_declaration_in_param168  */
static	ANTLR3_BITWORD FOLLOW_param_declaration_in_param168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_declaration_in_param168	= { FOLLOW_param_declaration_in_param168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_global182  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_global182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_global182	= { FOLLOW_VARIABLE_in_global182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_declaration_in_global185  */
static	ANTLR3_BITWORD FOLLOW_global_declaration_in_global185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_declaration_in_global185	= { FOLLOW_global_declaration_in_global185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_function198  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_function198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_function198	= { FOLLOW_FUNCTION_in_function198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_declaration_in_function201  */
static	ANTLR3_BITWORD FOLLOW_function_declaration_in_function201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_declaration_in_function201	= { FOLLOW_function_declaration_in_function201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param_declaration222  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param_declaration222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param_declaration222	= { FOLLOW_ID_in_param_declaration222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_param_declaration226  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_param_declaration226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_param_declaration226	= { FOLLOW_type_declaration_in_param_declaration226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_param_declaration232  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_param_declaration232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_param_declaration232	= { FOLLOW_NUMBER_in_param_declaration232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_global_declaration267  */
static	ANTLR3_BITWORD FOLLOW_ID_in_global_declaration267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_global_declaration267	= { FOLLOW_ID_in_global_declaration267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_global_declaration269  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_global_declaration269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_global_declaration269	= { FOLLOW_type_declaration_in_global_declaration269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_global_declaration275  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_global_declaration275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_global_declaration275	= { FOLLOW_NUMBER_in_global_declaration275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_argument_declaration308  */
static	ANTLR3_BITWORD FOLLOW_ID_in_argument_declaration308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_argument_declaration308	= { FOLLOW_ID_in_argument_declaration308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_argument_declaration310  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_argument_declaration310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_argument_declaration310	= { FOLLOW_type_declaration_in_argument_declaration310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_argument_declaration321  */
static	ANTLR3_BITWORD FOLLOW_ID_in_argument_declaration321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_argument_declaration321	= { FOLLOW_ID_in_argument_declaration321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_type_declaration339  */
static	ANTLR3_BITWORD FOLLOW_group_in_type_declaration339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_type_declaration339	= { FOLLOW_group_in_type_declaration339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_type_declaration346  */
static	ANTLR3_BITWORD FOLLOW_interval_in_type_declaration346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_type_declaration346	= { FOLLOW_interval_in_type_declaration346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_function_declaration364  */
static	ANTLR3_BITWORD FOLLOW_ID_in_function_declaration364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_function_declaration364	= { FOLLOW_ID_in_function_declaration364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPUT_in_function_declaration367  */
static	ANTLR3_BITWORD FOLLOW_OUTPUT_in_function_declaration367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPUT_in_function_declaration367	= { FOLLOW_OUTPUT_in_function_declaration367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_function_declaration370  */
static	ANTLR3_BITWORD FOLLOW_31_in_function_declaration370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_function_declaration370	= { FOLLOW_31_in_function_declaration370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration375  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration375	= { FOLLOW_argument_declaration_in_function_declaration375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INP_in_function_declaration388  */
static	ANTLR3_BITWORD FOLLOW_INP_in_function_declaration388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INP_in_function_declaration388	= { FOLLOW_INP_in_function_declaration388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_function_declaration391  */
static	ANTLR3_BITWORD FOLLOW_31_in_function_declaration391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_function_declaration391	= { FOLLOW_31_in_function_declaration391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration396  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration396	= { FOLLOW_argument_declaration_in_function_declaration396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_body_in_function_declaration412  */
static	ANTLR3_BITWORD FOLLOW_body_in_function_declaration412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_body_in_function_declaration412	= { FOLLOW_body_in_function_declaration412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BODY_in_body429  */
static	ANTLR3_BITWORD FOLLOW_BODY_in_body429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BODY_in_body429	= { FOLLOW_BODY_in_body429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_body431  */
static	ANTLR3_BITWORD FOLLOW_statement_in_body431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000204008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_body431	= { FOLLOW_statement_in_body431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_statement445  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_statement445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_statement445	= { FOLLOW_assignment_in_statement445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_statement450  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_statement450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_statement450	= { FOLLOW_function_call_in_statement450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_assignment466  */
static	ANTLR3_BITWORD FOLLOW_21_in_assignment466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_assignment466	= { FOLLOW_21_in_assignment466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_assignment468  */
static	ANTLR3_BITWORD FOLLOW_ID_in_assignment468_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_assignment468	= { FOLLOW_ID_in_assignment468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignment470  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignment470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignment470	= { FOLLOW_expr_in_assignment470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_function_call493  */
static	ANTLR3_BITWORD FOLLOW_ID_in_function_call493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_function_call493	= { FOLLOW_ID_in_function_call493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_function_call495  */
static	ANTLR3_BITWORD FOLLOW_argument_in_function_call495_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0021C008) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_function_call495	= { FOLLOW_argument_in_function_call495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_argument518  */
static	ANTLR3_BITWORD FOLLOW_expr_in_argument518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_argument518	= { FOLLOW_expr_in_argument518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_argument526  */
static	ANTLR3_BITWORD FOLLOW_group_in_argument526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_argument526	= { FOLLOW_group_in_argument526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GROUP_in_group542  */
static	ANTLR3_BITWORD FOLLOW_GROUP_in_group542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GROUP_in_group542	= { FOLLOW_GROUP_in_group542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_group547  */
static	ANTLR3_BITWORD FOLLOW_ID_in_group547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_group547	= { FOLLOW_ID_in_group547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_group563  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_group563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_group563	= { FOLLOW_NUMBER_in_group563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_alias592  */
static	ANTLR3_BITWORD FOLLOW_40_in_alias592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_alias592	= { FOLLOW_40_in_alias592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_alias594  */
static	ANTLR3_BITWORD FOLLOW_ID_in_alias594_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0021C018) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_alias594	= { FOLLOW_ID_in_alias594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_alias597  */
static	ANTLR3_BITWORD FOLLOW_group_in_alias597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_alias597	= { FOLLOW_group_in_alias597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_alias603  */
static	ANTLR3_BITWORD FOLLOW_interval_in_alias603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_alias603	= { FOLLOW_interval_in_alias603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTERVAL_in_interval627  */
static	ANTLR3_BITWORD FOLLOW_INTERVAL_in_interval627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INTERVAL_in_interval627	= { FOLLOW_INTERVAL_in_interval627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval629  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval629_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval629	= { FOLLOW_expr_in_interval629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval632  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval632	= { FOLLOW_expr_in_interval632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_expr654  */
static	ANTLR3_BITWORD FOLLOW_36_in_expr654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_expr654	= { FOLLOW_36_in_expr654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr658  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr658_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr658	= { FOLLOW_expr_in_expr658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr663  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr663	= { FOLLOW_expr_in_expr663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_expr673  */
static	ANTLR3_BITWORD FOLLOW_37_in_expr673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_expr673	= { FOLLOW_37_in_expr673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr677  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr677_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr677	= { FOLLOW_expr_in_expr677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr682  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr682	= { FOLLOW_expr_in_expr682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_expr692  */
static	ANTLR3_BITWORD FOLLOW_39_in_expr692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_expr692	= { FOLLOW_39_in_expr692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr696  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr696_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr696	= { FOLLOW_expr_in_expr696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr701  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr701	= { FOLLOW_expr_in_expr701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_expr711  */
static	ANTLR3_BITWORD FOLLOW_38_in_expr711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_expr711	= { FOLLOW_38_in_expr711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr715  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr715_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr715	= { FOLLOW_expr_in_expr715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr720  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr720	= { FOLLOW_expr_in_expr720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_expr730  */
static	ANTLR3_BITWORD FOLLOW_34_in_expr730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_expr730	= { FOLLOW_34_in_expr730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr734  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr734_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr734	= { FOLLOW_expr_in_expr734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr739  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr739	= { FOLLOW_expr_in_expr739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_expr749  */
static	ANTLR3_BITWORD FOLLOW_35_in_expr749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_expr749	= { FOLLOW_35_in_expr749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr753  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr753_bits[]	= { ANTLR3_UINT64_LIT(0x000000FC0020C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr753	= { FOLLOW_expr_in_expr753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr758  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr758	= { FOLLOW_expr_in_expr758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_expr767  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_expr767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_expr767	= { FOLLOW_function_call_in_expr767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_expr774  */
static	ANTLR3_BITWORD FOLLOW_ID_in_expr774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_expr774	= { FOLLOW_ID_in_expr774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expr783  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expr783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expr783	= { FOLLOW_NUMBER_in_expr783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_synpred1_codegen298  */
static	ANTLR3_BITWORD FOLLOW_ID_in_synpred1_codegen298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_synpred1_codegen298	= { FOLLOW_ID_in_synpred1_codegen298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_synpred1_codegen300  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_synpred1_codegen300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_synpred1_codegen300	= { FOLLOW_type_declaration_in_synpred1_codegen300_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start proof
 * codegen.g:130:1: proof[const char *part] : ^( PROOF execution_order common ( block[$part] )* ) ;
 */
static void
proof(pcodegen ctx, const char *part)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:131:2: ( ^( PROOF execution_order common ( block[$part] )* ) )
        // codegen.g:131:4: ^( PROOF execution_order common ( block[$part] )* )
        {
            if ( BACKTRACKING==0 ) 
            {
                 init_common(); 
            }
             MATCHT(PROOF, &FOLLOW_PROOF_in_proof51); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_execution_order_in_proof53);
            execution_order(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_common_in_proof55);
            common(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // codegen.g:131:53: ( block[$part] )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                case BLOCK:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // codegen.g:131:54: block[$part]
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_proof58);
            	        block(ctx, part);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproofEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproofEx; /* Prevent compiler warnings */
    ruleproofEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end proof */

/** 
 * $ANTLR start execution_order
 * codegen.g:134:1: execution_order : ^( ORDER ( step )* ) ;
 */
static void
execution_order(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:135:2: ( ^( ORDER ( step )* ) )
        // codegen.g:135:4: ^( ORDER ( step )* )
        {
             MATCHT(ORDER, &FOLLOW_ORDER_in_execution_order74); 
            if  (HASEXCEPTION())
            {
                goto ruleexecution_orderEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:135:12: ( step )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2) 
                    {
                	case 1:
                	    // codegen.g:135:13: step
                	    {
                	        FOLLOWPUSH(FOLLOW_step_in_execution_order77);
                	        step(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleexecution_orderEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexecution_orderEx; /* Prevent compiler warnings */
    ruleexecution_orderEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end execution_order */

/** 
 * $ANTLR start step
 * codegen.g:138:1: step : ^( ID ID ) ;
 */
static void
step(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:138:6: ( ^( ID ID ) )
        // codegen.g:138:8: ^( ID ID )
        {
             MATCHT(ID, &FOLLOW_ID_in_step92); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(ID, &FOLLOW_ID_in_step94); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestepEx; /* Prevent compiler warnings */
    rulestepEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end step */

/** 
 * $ANTLR start common
 * codegen.g:141:1: common : ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) ;
 */
static void
common(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:141:8: ( ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) )
        // codegen.g:141:10: ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_common106); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(ID, &FOLLOW_ID_in_common109); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( BACKTRACKING==0 ) 
            {
                 TheModule = Common; 
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:141:47: ( param )?
                {
                    int alt3=2;
                    switch ( LA(1) ) 
                    {
                        case PARAM:
                        	{
                        		alt3=1;
                        	}
                            break;
                    }

                    switch (alt3) 
                    {
                	case 1:
                	    // codegen.g:141:47: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_common113);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:141:54: ( global )?
                {
                    int alt4=2;
                    switch ( LA(1) ) 
                    {
                        case VARIABLE:
                        	{
                        		alt4=1;
                        	}
                            break;
                    }

                    switch (alt4) 
                    {
                	case 1:
                	    // codegen.g:141:54: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_common116);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:141:62: ( function )?
                {
                    int alt5=2;
                    switch ( LA(1) ) 
                    {
                        case FUNCTION:
                        	{
                        		alt5=1;
                        	}
                            break;
                    }

                    switch (alt5) 
                    {
                	case 1:
                	    // codegen.g:141:62: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_common119);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommonEx; /* Prevent compiler warnings */
    rulecommonEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end common */

/** 
 * $ANTLR start block
 * codegen.g:144:1: block[const char *part] : ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) ;
 */
static void
block(pcodegen ctx, const char *part)
{   
    pANTLR3_BASE_TREE    ID1;

    /* Initialize rule variables
     */


    ID1       = NULL;

    {
        // codegen.g:145:2: ( ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) )
        // codegen.g:145:4: ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block135); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            ID1 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_block138); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( BACKTRACKING==0 ) 
            {

                			Linker *linker = new Linker((const char*)(ID1->getText(ID1))->chars, (const char*)(ID1->getText(ID1))->chars, getGlobalContext());
                			linker->LinkInModule(Common);
                			TheModule = linker->getModule();
                			
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:149:6: ( param )?
                {
                    int alt6=2;
                    switch ( LA(1) ) 
                    {
                        case PARAM:
                        	{
                        		alt6=1;
                        	}
                            break;
                    }

                    switch (alt6) 
                    {
                	case 1:
                	    // codegen.g:149:6: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_block142);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:149:13: ( global )?
                {
                    int alt7=2;
                    switch ( LA(1) ) 
                    {
                        case VARIABLE:
                        	{
                        		alt7=1;
                        	}
                            break;
                    }

                    switch (alt7) 
                    {
                	case 1:
                	    // codegen.g:149:13: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_block145);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:149:21: ( function )?
                {
                    int alt8=2;
                    switch ( LA(1) ) 
                    {
                        case FUNCTION:
                        	{
                        		alt8=1;
                        	}
                            break;
                    }

                    switch (alt8) 
                    {
                	case 1:
                	    // codegen.g:149:21: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_block148);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 TheModule->dump(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end block */

/** 
 * $ANTLR start param
 * codegen.g:152:1: param : ^( PARAM ( param_declaration )* ) ;
 */
static void
param(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:152:7: ( ^( PARAM ( param_declaration )* ) )
        // codegen.g:152:9: ^( PARAM ( param_declaration )* )
        {
             MATCHT(PARAM, &FOLLOW_PARAM_in_param165); 
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:152:17: ( param_declaration )*

                for (;;)
                {
                    int alt9=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt9=1;
                    	}
                        break;

                    }

                    switch (alt9) 
                    {
                	case 1:
                	    // codegen.g:152:18: param_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_param_declaration_in_param168);
                	        param_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleparamEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop9;	/* break out of the loop */
                	    break;
                    }
                }
                loop9: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end param */

/** 
 * $ANTLR start global
 * codegen.g:155:1: global : ^( VARIABLE ( global_declaration )* ) ;
 */
static void
global(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:155:8: ( ^( VARIABLE ( global_declaration )* ) )
        // codegen.g:155:10: ^( VARIABLE ( global_declaration )* )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_global182); 
            if  (HASEXCEPTION())
            {
                goto ruleglobalEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:155:21: ( global_declaration )*

                for (;;)
                {
                    int alt10=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt10=1;
                    	}
                        break;

                    }

                    switch (alt10) 
                    {
                	case 1:
                	    // codegen.g:155:22: global_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_global_declaration_in_global185);
                	        global_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleglobalEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop10;	/* break out of the loop */
                	    break;
                    }
                }
                loop10: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobalEx; /* Prevent compiler warnings */
    ruleglobalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end global */

/** 
 * $ANTLR start function
 * codegen.g:158:1: function : ^( FUNCTION ( function_declaration )* ) ;
 */
static void
function(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:158:9: ( ^( FUNCTION ( function_declaration )* ) )
        // codegen.g:158:11: ^( FUNCTION ( function_declaration )* )
        {
             MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_function198); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:158:22: ( function_declaration )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11) 
                    {
                	case 1:
                	    // codegen.g:158:23: function_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_function_declaration_in_function201);
                	        function_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end function */

/** 
 * $ANTLR start param_declaration
 * codegen.g:161:1: param_declaration returns [Value *value] : ^(par= ID type= type_declaration ( NUMBER | ) ) ;
 */
static Value *
param_declaration(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    par;
    pANTLR3_BASE_TREE    NUMBER2;
    NumberT * type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type NumberT *

    /* Initialize rule variables
     */


    par       = NULL;
    NUMBER2       = NULL;
    type = NULL;

    {
        // codegen.g:162:2: ( ^(par= ID type= type_declaration ( NUMBER | ) ) )
        // codegen.g:162:4: ^(par= ID type= type_declaration ( NUMBER | ) )
        {
            par = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_param_declaration222); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_param_declaration226);
            type=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            // codegen.g:163:4: ( NUMBER | )
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                case NUMBER:
                	{
                		alt12=1;
                	}
                    break;
                case UP:
                	{
                		alt12=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return value;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleparam_declarationEx;
                }

                switch (alt12) 
                {
            	case 1:
            	    // codegen.g:163:5: NUMBER
            	    {
            	        NUMBER2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_param_declaration232); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparam_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(type->getBitWidth(), (const char*)(NUMBER2->getText(NUMBER2))->chars, 10));
            	        }

            	    }
            	    break;
            	case 2:
            	    // codegen.g:165:6: 
            	    {
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(type->getBitWidth(), 0)); 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                		Variable parx;
                		parx.value = value;
                		parx.type = type;
                		parx.variable = false;

                		Vars[(const char*) (par->getText(par))->chars] = parx;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparam_declarationEx; /* Prevent compiler warnings */
    ruleparam_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end param_declaration */

/** 
 * $ANTLR start global_declaration
 * codegen.g:176:1: global_declaration returns [Value *value] : ^(var= ID type_declaration ( NUMBER )? ) ;
 */
static Value *
global_declaration(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration3;
    #undef	RETURN_TYPE_type_declaration3
    #define	RETURN_TYPE_type_declaration3 NumberT *

    /* Initialize rule variables
     */


    var       = NULL;
    type_declaration3 = NULL;

    {
        // codegen.g:177:2: ( ^(var= ID type_declaration ( NUMBER )? ) )
        // codegen.g:177:4: ^(var= ID type_declaration ( NUMBER )? )
        {
            var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_global_declaration267); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_global_declaration269);
            type_declaration3=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {
                 	value= new GlobalVariable(*TheModule, type_declaration3->getType(), false, GlobalVariable::ExternalLinkage, 0, (const char *) (var->getText(var))->chars);
                	
            }

            // codegen.g:179:4: ( NUMBER )?
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                    case NUMBER:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13) 
                {
            	case 1:
            	    // codegen.g:179:5: NUMBER
            	    {
            	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_global_declaration275); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobal_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                		Variable varx;
                		varx.value = value;
                		varx.type = type_declaration3;
                		varx.variable = true;

                		Vars[(const char*) (var->getText(var))->chars] = varx;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobal_declarationEx; /* Prevent compiler warnings */
    ruleglobal_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end global_declaration */

/** 
 * $ANTLR start argument_declaration
 * codegen.g:190:1: argument_declaration returns [Arg *arg] : ( ( ^( ID type_declaration ) )=> ^(var= ID type_declaration ) | (var= ID ) );
 */
static Arg *
argument_declaration(pcodegen ctx)
{   
    Arg * arg = NULL;

    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration4;
    #undef	RETURN_TYPE_type_declaration4
    #define	RETURN_TYPE_type_declaration4 NumberT *

    /* Initialize rule variables
     */


    var       = NULL;
    type_declaration4 = NULL;

    {
        {
            //  codegen.g:191:2: ( ( ^( ID type_declaration ) )=> ^(var= ID type_declaration ) | (var= ID ) )
            
            ANTLR3_UINT32 alt14;

            alt14=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{

            		{
            		    int LA14_1 = LA(2);
            		    if ( (LA14_1 == DOWN) && (synpred1_codegen(ctx))) 
            		    {
            		        alt14=1;
            		    }
            		    else if ( (LA14_1 == UP || LA14_1 == ID) ) 
            		    {
            		        alt14=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return arg;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 1;


            		        goto ruleargument_declarationEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return arg;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleargument_declarationEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // codegen.g:191:4: ( ^( ID type_declaration ) )=> ^(var= ID type_declaration )
        	    {
        	        var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_argument_declaration308); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }
        	        FOLLOWPUSH(FOLLOW_type_declaration_in_argument_declaration310);
        	        type_declaration4=type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            		arg = new Arg();
        	            		arg->id = (const char*)(var->getText(var))->chars;
        	            		arg->type = type_declaration4;
        	            		arg->global_reference = false;
        	            		
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:197:4: (var= ID )
        	    {
        	        // codegen.g:197:4: (var= ID )
        	        // codegen.g:197:5: var= ID
        	        {
        	            var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_argument_declaration321); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleargument_declarationEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return arg;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {

        	                		arg = new Arg();
        	                		arg->id = (const char*)(var->getText(var))->chars;
        	                		arg->type = Vars[arg->id].type;
        	                		arg->value = Vars[arg->id].value;
        	                		arg->global_reference = true;
        	                		
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargument_declarationEx; /* Prevent compiler warnings */
    ruleargument_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return arg;
}
/* $ANTLR end argument_declaration */

/** 
 * $ANTLR start type_declaration
 * codegen.g:206:1: type_declaration returns [NumberT *type] : ( group | interval );
 */
static NumberT *
type_declaration(pcodegen ctx)
{   
    NumberT * type = NULL;

    NumberT * group5;
    #undef	RETURN_TYPE_group5
    #define	RETURN_TYPE_group5 NumberT *

    NumberT * interval6;
    #undef	RETURN_TYPE_interval6
    #define	RETURN_TYPE_interval6 NumberT *

    /* Initialize rule variables
     */


    group5 = NULL;
    interval6 = NULL;

    {
        {
            //  codegen.g:207:2: ( group | interval )
            
            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) ) 
            {
            case GROUP:
            	{
            		alt15=1;
            	}
                break;
            case INTERVAL:
            	{
            		alt15=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return type;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruletype_declarationEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // codegen.g:207:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_type_declaration339);
        	        group5=group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            type= group5; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:208:4: interval
        	    {
        	        FOLLOWPUSH(FOLLOW_interval_in_type_declaration346);
        	        interval6=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            type= interval6; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_declarationEx; /* Prevent compiler warnings */
    ruletype_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end type_declaration */

/** 
 * $ANTLR start function_declaration
 * codegen.g:211:1: function_declaration returns [Function *func, vector<Arg *> outs, vector<Arg *> inps] : ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) ;
 */
static codegen_function_declaration_return
function_declaration(pcodegen ctx)
{   
    codegen_function_declaration_return retval;

    pANTLR3_BASE_TREE    ID7;
    Arg * out;
    #undef	RETURN_TYPE_out
    #define	RETURN_TYPE_out Arg *

    Arg * inp;
    #undef	RETURN_TYPE_inp
    #define	RETURN_TYPE_inp Arg *

    /* Initialize rule variables
     */


    ID7       = NULL;
    out = NULL;
    inp = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // codegen.g:212:2: ( ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) )
        // codegen.g:212:4: ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? )
        {
            ID7 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_function_declaration364); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(OUTPUT, &FOLLOW_OUTPUT_in_function_declaration367); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:212:18: ( 'Void' | (out= argument_declaration )* )
                {
                    int alt17=2;
                    switch ( LA(1) ) 
                    {
                    case 31:
                    	{
                    		alt17=1;
                    	}
                        break;
                    case UP:
                    case ID:
                    	{
                    		alt17=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 17;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;
                    }

                    switch (alt17) 
                    {
                	case 1:
                	    // codegen.g:212:19: 'Void'
                	    {
                	         MATCHT(31, &FOLLOW_31_in_function_declaration370); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;
                	case 2:
                	    // codegen.g:212:26: (out= argument_declaration )*
                	    {

                	        // codegen.g:212:26: (out= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt16=2;
                	            switch ( LA(1) ) 
                	            {
                	            case ID:
                	            	{
                	            		alt16=1;
                	            	}
                	                break;

                	            }

                	            switch (alt16) 
                	            {
                	        	case 1:
                	        	    // codegen.g:212:27: out= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration375);
                	        	        out=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }
                	        	        if ( BACKTRACKING==0 ) 
                	        	        {
                	        	             retval.outs.push_back(out); 
                	        	        }

                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop16;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop16: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }
             MATCHT(INP, &FOLLOW_INP_in_function_declaration388); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:213:10: ( 'Void' | (inp= argument_declaration )* )
                {
                    int alt19=2;
                    switch ( LA(1) ) 
                    {
                    case 31:
                    	{
                    		alt19=1;
                    	}
                        break;
                    case UP:
                    case ID:
                    	{
                    		alt19=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;
                    }

                    switch (alt19) 
                    {
                	case 1:
                	    // codegen.g:213:11: 'Void'
                	    {
                	         MATCHT(31, &FOLLOW_31_in_function_declaration391); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;
                	case 2:
                	    // codegen.g:213:18: (inp= argument_declaration )*
                	    {

                	        // codegen.g:213:18: (inp= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt18=2;
                	            switch ( LA(1) ) 
                	            {
                	            case ID:
                	            	{
                	            		alt18=1;
                	            	}
                	                break;

                	            }

                	            switch (alt18) 
                	            {
                	        	case 1:
                	        	    // codegen.g:213:19: inp= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration396);
                	        	        inp=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }
                	        	        if ( BACKTRACKING==0 ) 
                	        	        {
                	        	             retval.inps.push_back(inp); 
                	        	        }

                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop18;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop18: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }
            if ( BACKTRACKING==0 ) 
            {

                			vector<Type *> Inps;
                			
                			for(vector<Arg *>::iterator i = retval.inps.begin(); i != retval.inps.end(); i++) {
                				Inps.push_back((*i)->type->getType());
                			}

                			FunctionType *FT;
                			
                			if(retval.outs.size() == 0) {
                				FT = FunctionType::get(Type::getVoidTy(getGlobalContext()), Inps, false);
                			} else {
                				FT = FunctionType::get(retval.outs[0]->type->getType(), Inps, false);
                			}
                		
                			retval.func= Function::Create(FT, Function::ExternalLinkage, (const char*) (ID7->getText(ID7))->chars, TheModule);
                			
                			BasicBlock *entry_block = BasicBlock::Create(getGlobalContext(), "entry", retval.func);
                			
                			Builder.SetInsertPoint(entry_block);
                			
                			for(vector<Arg*>::iterator def = retval.outs.begin(); def != retval.outs.end(); def++) {
                				if(!(*def)->global_reference) {
                					Variable varx;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					Vars[(*def)->id] = varx;
                				}
                			}
                			
                			vector<Arg*>::iterator def = retval.inps.begin();
                			
                			for(Function::arg_iterator arg = retval.func->arg_begin(); arg != retval.func->arg_end(); arg++, def++) {
                				if(!(*def)->global_reference)
                				{
                					arg->setName((*def)->id);
                				
                					Variable varx;
                					
                					varx.value = arg;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					Vars[(*def)->id] = varx;
                				} else {
                					arg->setName((*def)->id);
                				
                					Builder.CreateStore(arg, (*def)->value);
                				}
                			}			
                		
            }

            // codegen.g:266:3: ( body )?
            {
                int alt20=2;
                switch ( LA(1) ) 
                {
                    case BODY:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20) 
                {
            	case 1:
            	    // codegen.g:266:3: body
            	    {
            	        FOLLOWPUSH(FOLLOW_body_in_function_declaration412);
            	        body(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                	
                			if(retval.outs.size() > 0) {
                				Variable varx = Vars[retval.outs[0]->id];
                			
                				if(varx.variable) {
                					Builder.CreateRet(Builder.CreateLoad(varx.value, retval.outs[0]->id));
                				} else {
                					Builder.CreateRet(varx.value);
                				}
                			} else {
                				Builder.CreateRetVoid();
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunction_declarationEx; /* Prevent compiler warnings */
    rulefunction_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end function_declaration */

/** 
 * $ANTLR start body
 * codegen.g:282:1: body : ^( BODY ( statement )* ) ;
 */
static void
body(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:282:6: ( ^( BODY ( statement )* ) )
        // codegen.g:282:8: ^( BODY ( statement )* )
        {
             MATCHT(BODY, &FOLLOW_BODY_in_body429); 
            if  (HASEXCEPTION())
            {
                goto rulebodyEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:282:15: ( statement )*

                for (;;)
                {
                    int alt21=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    case 21:
                    	{
                    		alt21=1;
                    	}
                        break;

                    }

                    switch (alt21) 
                    {
                	case 1:
                	    // codegen.g:282:15: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_body431);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulebodyEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop21;	/* break out of the loop */
                	    break;
                    }
                }
                loop21: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end body */

/** 
 * $ANTLR start statement
 * codegen.g:285:1: statement : ( assignment | function_call );
 */
static void
statement(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  codegen.g:286:2: ( assignment | function_call )
            
            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) ) 
            {
            case 21:
            	{
            		alt22=1;
            	}
                break;
            case ID:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt22) 
            {
        	case 1:
        	    // codegen.g:286:4: assignment
        	    {
        	        FOLLOWPUSH(FOLLOW_assignment_in_statement445);
        	        assignment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:287:4: function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_statement450);
        	        function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start assignment
 * codegen.g:290:1: assignment returns [Value *value] : ^( ':=' ID expr[(const char*)$ID.text->chars] ) ;
 */
static Value *
assignment(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    ID8;
    codegen_expr_return expr9;
    #undef	RETURN_TYPE_expr9
    #define	RETURN_TYPE_expr9 codegen_expr_return

    /* Initialize rule variables
     */


    ID8       = NULL;

    {
        // codegen.g:291:2: ( ^( ':=' ID expr[(const char*)$ID.text->chars] ) )
        // codegen.g:291:4: ^( ':=' ID expr[(const char*)$ID.text->chars] )
        {
             MATCHT(21, &FOLLOW_21_in_assignment466); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            ID8 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_assignment468); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_expr_in_assignment470);
            expr9=expr(ctx, (const char*)(ID8->getText(ID8))->chars);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			const char *id = (const char*) (ID8->getText(ID8))->chars;
                		
                			Variable dest = Vars[id];
                			
                			if(!dest.variable) {
                				dest.value = expr9.value;
                				
                				Vars[id] = dest;
                			} else {
                				value= Builder.CreateStore(Builder.CreateIntCast(expr9.value, dest.type->getType(), false), dest.value);			
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end assignment */

/** 
 * $ANTLR start function_call
 * codegen.g:307:1: function_call returns [Value *value, NumberT *type] : ^( ID ( argument )* ) ;
 */
static codegen_function_call_return
function_call(pcodegen ctx)
{   
    codegen_function_call_return retval;

    pANTLR3_BASE_TREE    ID10;
    Value * argument11;
    #undef	RETURN_TYPE_argument11
    #define	RETURN_TYPE_argument11 Value *

    /* Initialize rule variables
     */


    ID10       = NULL;
    argument11 = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // codegen.g:308:2: ( ^( ID ( argument )* ) )
        // codegen.g:308:4: ^( ID ( argument )* )
        {
            ID10 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_function_call493); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_callEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_callEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:308:9: ( argument )*

                for (;;)
                {
                    int alt23=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    case NUMBER:
                    case GROUP:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    	{
                    		alt23=1;
                    	}
                        break;

                    }

                    switch (alt23) 
                    {
                	case 1:
                	    // codegen.g:308:9: argument
                	    {
                	        FOLLOWPUSH(FOLLOW_argument_in_function_call495);
                	        argument11=argument(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_callEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop23;	/* break out of the loop */
                	    break;
                    }
                }
                loop23: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_callEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }
            if ( BACKTRACKING==0 ) 
            {

                			Function *CalleeF = TheModule->getFunction((const char*) (ID10->getText(ID10))->chars);
                			vector<Value*> ArgsV;
                			
                			unsigned int idx = 0;
                			for(Function::arg_iterator AI = CalleeF->arg_begin(); AI != CalleeF->arg_end(); AI++, idx++) {
                				ArgsV.push_back(argument11);
                			}
                			
                			retval.value= Builder.CreateCall(CalleeF, ArgsV, "calltmp");
                			
                			retval.type= new GroupT(APInt(1024,0));
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end function_call */

/** 
 * $ANTLR start argument
 * codegen.g:324:1: argument returns [Value *value] : ( expr[\"arg\"] | group );
 */
static Value *
argument(pcodegen ctx)
{   
    Value * value = NULL;

    codegen_expr_return expr12;
    #undef	RETURN_TYPE_expr12
    #define	RETURN_TYPE_expr12 codegen_expr_return

    /* Initialize rule variables
     */


    {
        {
            //  codegen.g:325:2: ( expr[\"arg\"] | group )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case ID:
            case NUMBER:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            	{
            		alt24=1;
            	}
                break;
            case GROUP:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return value;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // codegen.g:325:4: expr[\"arg\"]
        	    {
        	        FOLLOWPUSH(FOLLOW_expr_in_argument518);
        	        expr12=expr(ctx, "arg");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             value= expr12.value; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:326:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_argument526);
        	        group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end argument */

/** 
 * $ANTLR start group
 * codegen.g:329:1: group returns [NumberT *type] : ^( GROUP ( ID | NUMBER )? ) ;
 */
static NumberT *
group(pcodegen ctx)
{   
    NumberT * type = NULL;

    pANTLR3_BASE_TREE    ID13;
    pANTLR3_BASE_TREE    NUMBER14;

    /* Initialize rule variables
     */


    ID13       = NULL;
    NUMBER14       = NULL;

    {
        // codegen.g:330:2: ( ^( GROUP ( ID | NUMBER )? ) )
        // codegen.g:330:4: ^( GROUP ( ID | NUMBER )? )
        {
             MATCHT(GROUP, &FOLLOW_GROUP_in_group542); 
            if  (HASEXCEPTION())
            {
                goto rulegroupEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            if ( BACKTRACKING==0 ) 
            {
                type= new GroupT(APInt(32, 0));
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulegroupEx;
                }
                if (HASFAILED())
                {
                    return type;
                }

                // codegen.g:330:48: ( ID | NUMBER )?
                {
                    int alt25=3;
                    switch ( LA(1) ) 
                    {
                        case ID:
                        	{
                        		alt25=1;
                        	}
                            break;
                        case NUMBER:
                        	{
                        		alt25=2;
                        	}
                            break;
                    }

                    switch (alt25) 
                    {
                	case 1:
                	    // codegen.g:330:49: ID
                	    {
                	        ID13 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_group547); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulegroupEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return type;
                	        }
                	        if ( BACKTRACKING==0 ) 
                	        {

                	            				Variable var = Vars[(const char*)(ID13->getText(ID13))->chars];
                	            				
                	            				type= new GroupT(static_cast<ConstantInt*>(var.value)->getValue());
                	            			
                	        }

                	    }
                	    break;
                	case 2:
                	    // codegen.g:336:6: NUMBER
                	    {
                	        NUMBER14 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_group563); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulegroupEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return type;
                	        }
                	        if ( BACKTRACKING==0 ) 
                	        {

                	            				unsigned int bits = atoi((const char*)(NUMBER14->getText(NUMBER14))->chars);
                	            									
                	            				type= new GroupT(APInt(bits, 0));
                	            				//type= new NumberT(bits);
                	            			
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulegroupEx;
                }
                if (HASFAILED())
                {
                    return type;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegroupEx; /* Prevent compiler warnings */
    rulegroupEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end group */

/** 
 * $ANTLR start alias
 * codegen.g:346:1: alias returns [NumberT *type] : ^( '=' ID ( group | interval ) ) ;
 */
static NumberT *
alias(pcodegen ctx)
{   
    NumberT * type = NULL;

    pANTLR3_BASE_TREE    ID17;
    NumberT * group15;
    #undef	RETURN_TYPE_group15
    #define	RETURN_TYPE_group15 NumberT *

    NumberT * interval16;
    #undef	RETURN_TYPE_interval16
    #define	RETURN_TYPE_interval16 NumberT *

    /* Initialize rule variables
     */


    ID17       = NULL;
    group15 = NULL;
    interval16 = NULL;

    {
        // codegen.g:347:2: ( ^( '=' ID ( group | interval ) ) )
        // codegen.g:347:4: ^( '=' ID ( group | interval ) )
        {
             MATCHT(40, &FOLLOW_40_in_alias592); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            ID17 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_alias594); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            // codegen.g:347:13: ( group | interval )
            {
                int alt26=2;
                switch ( LA(1) ) 
                {
                case GROUP:
                	{
                		alt26=1;
                	}
                    break;
                case INTERVAL:
                	{
                		alt26=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return type;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto rulealiasEx;
                }

                switch (alt26) 
                {
            	case 1:
            	    // codegen.g:347:14: group
            	    {
            	        FOLLOWPUSH(FOLLOW_group_in_alias597);
            	        group15=group(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            type=group15; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // codegen.g:347:44: interval
            	    {
            	        FOLLOWPUSH(FOLLOW_interval_in_alias603);
            	        interval16=interval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            type=interval16; 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            if ( BACKTRACKING==0 ) 
            {

                			Types[(const char*)(ID17->getText(ID17))->chars] = type;
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end alias */

/** 
 * $ANTLR start interval
 * codegen.g:353:1: interval returns [NumberT *type] : ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) ;
 */
static NumberT *
interval(pcodegen ctx)
{   
    NumberT * type = NULL;

    /* Initialize rule variables
     */


    {
        // codegen.g:354:2: ( ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) )
        // codegen.g:354:3: ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] )
        {
             MATCHT(INTERVAL, &FOLLOW_INTERVAL_in_interval627); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            FOLLOWPUSH(FOLLOW_expr_in_interval629);
            expr(ctx, "lhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            FOLLOWPUSH(FOLLOW_expr_in_interval632);
            expr(ctx, "rhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            if ( BACKTRACKING==0 ) 
            {
                type= new GroupT(APInt(32, 0)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintervalEx; /* Prevent compiler warnings */
    ruleintervalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end interval */

/** 
 * $ANTLR start expr
 * codegen.g:357:1: expr[const char *id] returns [Value *value, NumberT *type] : ( ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call | ID | NUMBER );
 */
static codegen_expr_return
expr(pcodegen ctx, const char *id)
{   
    codegen_expr_return retval;

    pANTLR3_BASE_TREE    ID19;
    pANTLR3_BASE_TREE    NUMBER20;
    codegen_expr_return lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs codegen_expr_return

    codegen_expr_return rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs codegen_expr_return

    codegen_function_call_return function_call18;
    #undef	RETURN_TYPE_function_call18
    #define	RETURN_TYPE_function_call18 codegen_function_call_return

    /* Initialize rule variables
     */


    ID19       = NULL;
    NUMBER20       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  codegen.g:358:2: ( ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call | ID | NUMBER )
            
            ANTLR3_UINT32 alt27;

            alt27=9;

            switch ( LA(1) ) 
            {
            case 36:
            	{
            		alt27=1;
            	}
                break;
            case 37:
            	{
            		alt27=2;
            	}
                break;
            case 39:
            	{
            		alt27=3;
            	}
                break;
            case 38:
            	{
            		alt27=4;
            	}
                break;
            case 34:
            	{
            		alt27=5;
            	}
                break;
            case 35:
            	{
            		alt27=6;
            	}
                break;
            case ID:
            	{
            		switch ( LA(2) ) 
            		{
            		case DOWN:
            			{
            				alt27=7;
            			}
            		    break;
            		case UP:
            		case ID:
            		case NUMBER:
            		case GROUP:
            		case 34:
            		case 35:
            		case 36:
            		case 37:
            		case 38:
            		case 39:
            			{
            				alt27=8;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 27;
            		    EXCEPTION->state        = 7;


            		    goto ruleexprEx;
            		}

            	}
                break;
            case NUMBER:
            	{
            		alt27=9;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleexprEx;
            }

            switch (alt27) 
            {
        	case 1:
        	    // codegen.g:358:4: ^( '+' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(36, &FOLLOW_36_in_expr654); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr658);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr663);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= lhs.type + *rhs.type; retval.value= operator_call(id, "modadd1024", lhs.value, rhs.value, 
        	            			Builder.CreateIntCast(dynamic_cast<GroupT*>(retval.type)->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:360:4: ^( '-' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(37, &FOLLOW_37_in_expr673); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr677);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr682);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= lhs.type - *rhs.type; retval.value= operator_call(id, "modsub1024", lhs.value, rhs.value,
        	            			Builder.CreateIntCast(dynamic_cast<GroupT*>(retval.type)->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // codegen.g:362:4: ^( '*' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(39, &FOLLOW_39_in_expr692); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr696);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr701);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= lhs.type * *rhs.type; retval.value= operator_call(id, "modmul1024", lhs.value, rhs.value,
        	            			Builder.CreateIntCast(dynamic_cast<GroupT*>(retval.type)->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // codegen.g:364:4: ^( '^' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(38, &FOLLOW_38_in_expr711); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr715);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr720);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= lhs.type ^ *rhs.type; retval.value= operator_call(id, "modexp1024", lhs.value, rhs.value,
        	            			Builder.CreateIntCast(dynamic_cast<GroupT*>(retval.type)->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // codegen.g:366:4: ^( '==' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(34, &FOLLOW_34_in_expr730); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr734);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr739);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.value= Builder.CreateICmpEQ(lhs.value, rhs.value, id);
        	        }

        	    }
        	    break;
        	case 6:
        	    // codegen.g:367:4: ^( '!=' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(35, &FOLLOW_35_in_expr749); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr753);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr758);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.value= Builder.CreateICmpNE(lhs.value, rhs.value, id);
        	        }

        	    }
        	    break;
        	case 7:
        	    // codegen.g:368:4: function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_expr767);
        	        function_call18=function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= function_call18.type; retval.value= function_call18.value;
        	        }

        	    }
        	    break;
        	case 8:
        	    // codegen.g:369:4: ID
        	    {
        	        ID19 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_expr774); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			Variable varx = Vars[(const char *) (ID19->getText(ID19))->chars];
        	            			retval.type= varx.type;
        	            			if(!varx.variable) {
        	            				retval.value= Builder.CreateIntCast(varx.value, IntegerType::get(getGlobalContext(), 1024), false, (const char*)(ID19->getText(ID19))->chars);
        	            			} else {
        	            				retval.value= Builder.CreateIntCast(Builder.CreateLoad(varx.value, (const char*) (ID19->getText(ID19))->chars), IntegerType::get(getGlobalContext(), 1024), false, (const char*)(ID19->getText(ID19))->chars);
        	            			}
        	            		
        	        }

        	    }
        	    break;
        	case 9:
        	    // codegen.g:379:4: NUMBER
        	    {
        	        NUMBER20 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expr783); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.value= ConstantInt::get(getGlobalContext(), APInt(1024, (const char*) (NUMBER20->getText(NUMBER20))->chars, 10));
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end expr */

// $ANTLR start synpred1_codegen
static void synpred1_codegen_fragment(pcodegen ctx ) 
{
    // codegen.g:191:4: ( ^( ID type_declaration ) )
    // codegen.g:191:5: ^( ID type_declaration )
    {
         MATCHT(ID, &FOLLOW_ID_in_synpred1_codegen298); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_type_declaration_in_synpred1_codegen300);
        type_declaration(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_codegenEx; /* Prevent compiler warnings */
rulesynpred1_codegenEx: ;

}
// $ANTLR end synpred1_codegen
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_codegen(pcodegen ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_codegen_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
