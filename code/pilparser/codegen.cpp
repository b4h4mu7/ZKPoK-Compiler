/** \file
 *  This C source file was generated by $ANTLR version 3.2 Fedora release 15 (Rawhide) Tue Feb  8 02:02:23 UTC 2011
 *
 *     -  From the grammar source file : codegen.g
 *     -                            On : 2012-03-15 03:39:38
 *     -           for the tree parser : codegenTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "codegen.h"

	struct cmp_str
	{
		bool operator()(const char *a, const char *b)
		{
			return strcmp(a, b) < 0;
		}
	};
	
	static Module *Common = new Module("Common", getGlobalContext());
	static Module *TheModule;
	static IRBuilder<> Builder(getGlobalContext());
	static map<const char*, Variable, cmp_str> Vars;
	static map<const char*, NumberT*, cmp_str> Types;
				
	Value* operator_call(const char *name, const char *fname, Value *a, Value *b, Value *mod)
	{
		Function *function = TheModule->getFunction(fname);
	
		vector<Value*> args;
		
		args.push_back(a);
		args.push_back(b);
		args.push_back(mod);
		
		return Builder.CreateCall(function, args, name);
	}
	
	void init_common() 
	{
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(0, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "Random", Common);		
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(1, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "CheckMembership", Common);
		
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modadd1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modsub1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modmul1024", Common);
	
		Function::Create(
			FunctionType::get(
				Type::getIntNTy(getGlobalContext(), 1024),
				vector<Type *>(3, Type::getIntNTy(getGlobalContext(), 1024)),
				false),
			Function::ExternalLinkage, "modexp1024", Common);
		
		Function::Create(
			FunctionType::get(
				Type::getInt1Ty(getGlobalContext()),
				vector<Type *>(1, Type::getInt1Ty(getGlobalContext())),
				false),
			Function::ExternalLinkage, "Verify", Common);
	}

	NumberT *NumberT::addWithSubFrom(const NumberT *first) const { return const_cast<NumberT*>(first); }
	NumberT *NumberT::addWithSubFrom(const GroupT *first) const { return const_cast<GroupT*>(first); }
	  
	NumberT *NumberT::mulWithExpOn(const NumberT *first) const { return const_cast<NumberT*>(first); }
	NumberT *NumberT::mulWithExpOn(const GroupT *first) const { return const_cast<GroupT*>(first); }
	
	Value * NumberT::createNeg(Value *a) const  {
		return Builder.CreateNeg(a);
	}
	
	Value * NumberT::createAdd(Value *a, Value *b) const {
		return Builder.CreateAdd(a, b);
	}
	
	Value * NumberT::createSub(Value *a, Value *b) const {
		return Builder.CreateSub(a, b);
	}
	
	Value * NumberT::createMul(Value *a, Value *b) const {
		return Builder.CreateMul(a, b);
	}
	
	Value * NumberT::createExp(Value *a, Value *b) const {
		return Builder.CreateMul(a, b);
	}
	
	Value * GroupT::createNeg(Value *a) const {
		return operator_call("", "modsub1024", ConstantInt::get(getGlobalContext(), APInt(1024, 0)), a, Builder.CreateIntCast(this->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false));
	}
	
	Value * GroupT::createAdd(Value *a, Value *b) const {
		return operator_call("", "modadd1024", a, b, Builder.CreateIntCast(this->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 	
	}
	
	Value * GroupT::createSub(Value *a, Value *b) const {
		return operator_call("", "modsub1024", a, b, Builder.CreateIntCast(this->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 		
	}
	
	Value * GroupT::createMul(Value *a, Value *b) const {
		return operator_call("", "modmul1024", a, b, Builder.CreateIntCast(this->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 	
	}
	
	Value * GroupT::createExp(Value *a, Value *b) const {
		return operator_call("", "modexp1024", a, b, Builder.CreateIntCast(this->getModulusConstant(), IntegerType::get(getGlobalContext(), 1024), false)); 	
	}

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pcodegen_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcodegen_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pcodegen_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pcodegen_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   codegenTokenNames[46+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "INTERVAL",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PROOF",
        (pANTLR3_UINT8) "ORDER",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "INP",
        (pANTLR3_UINT8) "OUTPUT",
        (pANTLR3_UINT8) "BODY",
        (pANTLR3_UINT8) "VARIABLE",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "NEWLINE",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'ExecutionOrder'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'Def'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'Void'",
        (pANTLR3_UINT8) "'IfKnown'",
        (pANTLR3_UINT8) "'Else'",
        (pANTLR3_UINT8) "'=='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'^'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'Random'",
        (pANTLR3_UINT8) "'Verify'",
        (pANTLR3_UINT8) "'CheckMembership'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'Zmod+'",
        (pANTLR3_UINT8) "'Zmod*'",
        (pANTLR3_UINT8) "'Prime'",
        (pANTLR3_UINT8) "'Int'",
        (pANTLR3_UINT8) "'Z'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	proof    (pcodegen ctx, const char *part);
static void	execution_order    (pcodegen ctx);
static void	step    (pcodegen ctx);
static void	common    (pcodegen ctx);
static void	block    (pcodegen ctx, const char *part);
static void	param    (pcodegen ctx);
static void	global    (pcodegen ctx);
static void	function    (pcodegen ctx);
static Value *	param_declaration    (pcodegen ctx);
static Value *	global_declaration    (pcodegen ctx);
static Arg *	argument_declaration    (pcodegen ctx);
static NumberT *	type_declaration    (pcodegen ctx);
static codegen_function_declaration_return	function_declaration    (pcodegen ctx);
static void	body    (pcodegen ctx);
static void	statement    (pcodegen ctx);
static Value *	assignment    (pcodegen ctx);
static codegen_function_call_return	function_call    (pcodegen ctx);
static Value *	argument    (pcodegen ctx);
static NumberT *	group    (pcodegen ctx);
static NumberT *	alias    (pcodegen ctx);
static NumberT *	interval    (pcodegen ctx);
static codegen_expr_return	expr    (pcodegen ctx, const char *id);
static ANTLR3_BOOLEAN	synpred1_codegen    (pcodegen ctx);
static void	codegenFree(pcodegen ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "codegen.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return codegenNewSSD(instream, NULL);
}

/** \brief Create a new codegen parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcodegen
codegenNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcodegen ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pcodegen) ANTLR3_CALLOC(1, sizeof(codegen));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in codegen.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our codegen interface
     */
    ctx->proof	= proof;
    ctx->execution_order	= execution_order;
    ctx->step	= step;
    ctx->common	= common;
    ctx->block	= block;
    ctx->param	= param;
    ctx->global	= global;
    ctx->function	= function;
    ctx->param_declaration	= param_declaration;
    ctx->global_declaration	= global_declaration;
    ctx->argument_declaration	= argument_declaration;
    ctx->type_declaration	= type_declaration;
    ctx->function_declaration	= function_declaration;
    ctx->body	= body;
    ctx->statement	= statement;
    ctx->assignment	= assignment;
    ctx->function_call	= function_call;
    ctx->argument	= argument;
    ctx->group	= group;
    ctx->alias	= alias;
    ctx->interval	= interval;
    ctx->expr	= expr;
    ctx->synpred1_codegen	= synpred1_codegen;
    ctx->free			= codegenFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = codegenTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 codegenFree(pcodegen ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return codegenTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_PROOF_in_proof51  */
static	ANTLR3_BITWORD FOLLOW_PROOF_in_proof51_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PROOF_in_proof51	= { FOLLOW_PROOF_in_proof51_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_execution_order_in_proof53  */
static	ANTLR3_BITWORD FOLLOW_execution_order_in_proof53_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_execution_order_in_proof53	= { FOLLOW_execution_order_in_proof53_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_in_proof55  */
static	ANTLR3_BITWORD FOLLOW_common_in_proof55_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_common_in_proof55	= { FOLLOW_common_in_proof55_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_proof58  */
static	ANTLR3_BITWORD FOLLOW_block_in_proof58_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000108) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_proof58	= { FOLLOW_block_in_proof58_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ORDER_in_execution_order74  */
static	ANTLR3_BITWORD FOLLOW_ORDER_in_execution_order74_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ORDER_in_execution_order74	= { FOLLOW_ORDER_in_execution_order74_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_step_in_execution_order77  */
static	ANTLR3_BITWORD FOLLOW_step_in_execution_order77_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_step_in_execution_order77	= { FOLLOW_step_in_execution_order77_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_step92  */
static	ANTLR3_BITWORD FOLLOW_ID_in_step92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_step92	= { FOLLOW_ID_in_step92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_step94  */
static	ANTLR3_BITWORD FOLLOW_ID_in_step94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_step94	= { FOLLOW_ID_in_step94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_common106  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_common106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_common106	= { FOLLOW_BLOCK_in_common106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_common109  */
static	ANTLR3_BITWORD FOLLOW_ID_in_common109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_common109	= { FOLLOW_ID_in_common109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_common113  */
static	ANTLR3_BITWORD FOLLOW_param_in_common113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_common113	= { FOLLOW_param_in_common113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_common116  */
static	ANTLR3_BITWORD FOLLOW_global_in_common116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_common116	= { FOLLOW_global_in_common116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_common119  */
static	ANTLR3_BITWORD FOLLOW_function_in_common119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_common119	= { FOLLOW_function_in_common119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block135  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block135	= { FOLLOW_BLOCK_in_block135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_block138  */
static	ANTLR3_BITWORD FOLLOW_ID_in_block138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_block138	= { FOLLOW_ID_in_block138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_block142  */
static	ANTLR3_BITWORD FOLLOW_param_in_block142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000003008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_block142	= { FOLLOW_param_in_block142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_in_block145  */
static	ANTLR3_BITWORD FOLLOW_global_in_block145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_in_block145	= { FOLLOW_global_in_block145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_in_block148  */
static	ANTLR3_BITWORD FOLLOW_function_in_block148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_in_block148	= { FOLLOW_function_in_block148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAM_in_param165  */
static	ANTLR3_BITWORD FOLLOW_PARAM_in_param165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAM_in_param165	= { FOLLOW_PARAM_in_param165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_declaration_in_param168  */
static	ANTLR3_BITWORD FOLLOW_param_declaration_in_param168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_param_declaration_in_param168	= { FOLLOW_param_declaration_in_param168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_global182  */
static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_global182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_global182	= { FOLLOW_VARIABLE_in_global182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_global_declaration_in_global185  */
static	ANTLR3_BITWORD FOLLOW_global_declaration_in_global185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_global_declaration_in_global185	= { FOLLOW_global_declaration_in_global185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_function198  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_function198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_function198	= { FOLLOW_FUNCTION_in_function198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_declaration_in_function201  */
static	ANTLR3_BITWORD FOLLOW_function_declaration_in_function201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_function_declaration_in_function201	= { FOLLOW_function_declaration_in_function201_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param_declaration222  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param_declaration222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param_declaration222	= { FOLLOW_ID_in_param_declaration222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_param_declaration226  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_param_declaration226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_param_declaration226	= { FOLLOW_type_declaration_in_param_declaration226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_param_declaration232  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_param_declaration232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_param_declaration232	= { FOLLOW_NUMBER_in_param_declaration232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_global_declaration267  */
static	ANTLR3_BITWORD FOLLOW_ID_in_global_declaration267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_global_declaration267	= { FOLLOW_ID_in_global_declaration267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_global_declaration269  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_global_declaration269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_global_declaration269	= { FOLLOW_type_declaration_in_global_declaration269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_global_declaration275  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_global_declaration275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_global_declaration275	= { FOLLOW_NUMBER_in_global_declaration275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_argument_declaration308  */
static	ANTLR3_BITWORD FOLLOW_ID_in_argument_declaration308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_argument_declaration308	= { FOLLOW_ID_in_argument_declaration308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_argument_declaration310  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_argument_declaration310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_argument_declaration310	= { FOLLOW_type_declaration_in_argument_declaration310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_argument_declaration321  */
static	ANTLR3_BITWORD FOLLOW_ID_in_argument_declaration321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_argument_declaration321	= { FOLLOW_ID_in_argument_declaration321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_type_declaration339  */
static	ANTLR3_BITWORD FOLLOW_group_in_type_declaration339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_type_declaration339	= { FOLLOW_group_in_type_declaration339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_type_declaration346  */
static	ANTLR3_BITWORD FOLLOW_interval_in_type_declaration346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_type_declaration346	= { FOLLOW_interval_in_type_declaration346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_function_declaration364  */
static	ANTLR3_BITWORD FOLLOW_ID_in_function_declaration364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_function_declaration364	= { FOLLOW_ID_in_function_declaration364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OUTPUT_in_function_declaration367  */
static	ANTLR3_BITWORD FOLLOW_OUTPUT_in_function_declaration367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OUTPUT_in_function_declaration367	= { FOLLOW_OUTPUT_in_function_declaration367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_function_declaration370  */
static	ANTLR3_BITWORD FOLLOW_30_in_function_declaration370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_function_declaration370	= { FOLLOW_30_in_function_declaration370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration375  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration375	= { FOLLOW_argument_declaration_in_function_declaration375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INP_in_function_declaration388  */
static	ANTLR3_BITWORD FOLLOW_INP_in_function_declaration388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INP_in_function_declaration388	= { FOLLOW_INP_in_function_declaration388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_function_declaration391  */
static	ANTLR3_BITWORD FOLLOW_30_in_function_declaration391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_function_declaration391	= { FOLLOW_30_in_function_declaration391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_declaration_in_function_declaration396  */
static	ANTLR3_BITWORD FOLLOW_argument_declaration_in_function_declaration396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_declaration_in_function_declaration396	= { FOLLOW_argument_declaration_in_function_declaration396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_body_in_function_declaration412  */
static	ANTLR3_BITWORD FOLLOW_body_in_function_declaration412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_body_in_function_declaration412	= { FOLLOW_body_in_function_declaration412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BODY_in_body429  */
static	ANTLR3_BITWORD FOLLOW_BODY_in_body429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BODY_in_body429	= { FOLLOW_BODY_in_body429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_body431  */
static	ANTLR3_BITWORD FOLLOW_statement_in_body431_bits[]	= { ANTLR3_UINT64_LIT(0x0000038000100008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_body431	= { FOLLOW_statement_in_body431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_statement445  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_statement445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_statement445	= { FOLLOW_assignment_in_statement445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_statement450  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_statement450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_statement450	= { FOLLOW_function_call_in_statement450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_assignment466  */
static	ANTLR3_BITWORD FOLLOW_20_in_assignment466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_assignment466	= { FOLLOW_20_in_assignment466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_assignment468  */
static	ANTLR3_BITWORD FOLLOW_ID_in_assignment468_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_assignment468	= { FOLLOW_ID_in_assignment468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_assignment470  */
static	ANTLR3_BITWORD FOLLOW_expr_in_assignment470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_assignment470	= { FOLLOW_expr_in_assignment470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_function_call493  */
static	ANTLR3_BITWORD FOLLOW_39_in_function_call493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_function_call493	= { FOLLOW_39_in_function_call493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_function_call495  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_function_call495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_function_call495	= { FOLLOW_type_declaration_in_function_call495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_function_call506  */
static	ANTLR3_BITWORD FOLLOW_41_in_function_call506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_function_call506	= { FOLLOW_41_in_function_call506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_function_call508  */
static	ANTLR3_BITWORD FOLLOW_argument_in_function_call508_bits[]	= { ANTLR3_UINT64_LIT(0x0000F80000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_function_call508	= { FOLLOW_argument_in_function_call508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_function_call510  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_function_call510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_function_call510	= { FOLLOW_type_declaration_in_function_call510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_function_call521  */
static	ANTLR3_BITWORD FOLLOW_40_in_function_call521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_function_call521	= { FOLLOW_40_in_function_call521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_function_call523  */
static	ANTLR3_BITWORD FOLLOW_expr_in_function_call523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_function_call523	= { FOLLOW_expr_in_function_call523_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_argument546  */
static	ANTLR3_BITWORD FOLLOW_expr_in_argument546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_argument546	= { FOLLOW_expr_in_argument546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_argument554  */
static	ANTLR3_BITWORD FOLLOW_group_in_argument554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_argument554	= { FOLLOW_group_in_argument554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_group569  */
static	ANTLR3_BITWORD FOLLOW_47_in_group569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_group569	= { FOLLOW_47_in_group569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_group577  */
static	ANTLR3_BITWORD FOLLOW_45_in_group577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_group577	= { FOLLOW_45_in_group577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group579  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group579	= { FOLLOW_expr_in_group579_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_group589  */
static	ANTLR3_BITWORD FOLLOW_46_in_group589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_group589	= { FOLLOW_46_in_group589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group591  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group591	= { FOLLOW_expr_in_group591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_group601  */
static	ANTLR3_BITWORD FOLLOW_43_in_group601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_group601	= { FOLLOW_43_in_group601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group603  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group603	= { FOLLOW_expr_in_group603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_group613  */
static	ANTLR3_BITWORD FOLLOW_44_in_group613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_group613	= { FOLLOW_44_in_group613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_group615  */
static	ANTLR3_BITWORD FOLLOW_expr_in_group615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_group615	= { FOLLOW_expr_in_group615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_alias635  */
static	ANTLR3_BITWORD FOLLOW_42_in_alias635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_alias635	= { FOLLOW_42_in_alias635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_alias637  */
static	ANTLR3_BITWORD FOLLOW_ID_in_alias637_bits[]	= { ANTLR3_UINT64_LIT(0x0000F80000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_alias637	= { FOLLOW_ID_in_alias637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_in_alias640  */
static	ANTLR3_BITWORD FOLLOW_group_in_alias640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_group_in_alias640	= { FOLLOW_group_in_alias640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_alias646  */
static	ANTLR3_BITWORD FOLLOW_interval_in_alias646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_alias646	= { FOLLOW_interval_in_alias646_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTERVAL_in_interval670  */
static	ANTLR3_BITWORD FOLLOW_INTERVAL_in_interval670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INTERVAL_in_interval670	= { FOLLOW_INTERVAL_in_interval670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval672  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval672_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval672	= { FOLLOW_expr_in_interval672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_interval675  */
static	ANTLR3_BITWORD FOLLOW_expr_in_interval675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_interval675	= { FOLLOW_expr_in_interval675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_expr697  */
static	ANTLR3_BITWORD FOLLOW_36_in_expr697_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_expr697	= { FOLLOW_36_in_expr697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr701  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr701	= { FOLLOW_expr_in_expr701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_expr711  */
static	ANTLR3_BITWORD FOLLOW_35_in_expr711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_expr711	= { FOLLOW_35_in_expr711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr715  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr715_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr715	= { FOLLOW_expr_in_expr715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr720  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr720	= { FOLLOW_expr_in_expr720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_expr730  */
static	ANTLR3_BITWORD FOLLOW_36_in_expr730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_expr730	= { FOLLOW_36_in_expr730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr734  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr734_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr734	= { FOLLOW_expr_in_expr734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr739  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr739	= { FOLLOW_expr_in_expr739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_expr749  */
static	ANTLR3_BITWORD FOLLOW_38_in_expr749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_expr749	= { FOLLOW_38_in_expr749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr753  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr753_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr753	= { FOLLOW_expr_in_expr753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr758  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr758	= { FOLLOW_expr_in_expr758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_expr768  */
static	ANTLR3_BITWORD FOLLOW_37_in_expr768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_expr768	= { FOLLOW_37_in_expr768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr772  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr772_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr772	= { FOLLOW_expr_in_expr772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr777  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr777	= { FOLLOW_expr_in_expr777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_expr787  */
static	ANTLR3_BITWORD FOLLOW_33_in_expr787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_expr787	= { FOLLOW_33_in_expr787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr791  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr791_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr791	= { FOLLOW_expr_in_expr791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr796  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr796	= { FOLLOW_expr_in_expr796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_expr806  */
static	ANTLR3_BITWORD FOLLOW_34_in_expr806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_expr806	= { FOLLOW_34_in_expr806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr810  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr810_bits[]	= { ANTLR3_UINT64_LIT(0x000003FE0010C008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr810	= { FOLLOW_expr_in_expr810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_expr815  */
static	ANTLR3_BITWORD FOLLOW_expr_in_expr815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_expr815	= { FOLLOW_expr_in_expr815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_call_in_expr824  */
static	ANTLR3_BITWORD FOLLOW_function_call_in_expr824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_call_in_expr824	= { FOLLOW_function_call_in_expr824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_expr831  */
static	ANTLR3_BITWORD FOLLOW_ID_in_expr831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_expr831	= { FOLLOW_ID_in_expr831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expr840  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expr840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expr840	= { FOLLOW_NUMBER_in_expr840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_synpred1_codegen298  */
static	ANTLR3_BITWORD FOLLOW_ID_in_synpred1_codegen298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_synpred1_codegen298	= { FOLLOW_ID_in_synpred1_codegen298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_declaration_in_synpred1_codegen300  */
static	ANTLR3_BITWORD FOLLOW_type_declaration_in_synpred1_codegen300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_type_declaration_in_synpred1_codegen300	= { FOLLOW_type_declaration_in_synpred1_codegen300_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start proof
 * codegen.g:171:1: proof[const char *part] : ^( PROOF execution_order common ( block[$part] )* ) ;
 */
static void
proof(pcodegen ctx, const char *part)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:172:2: ( ^( PROOF execution_order common ( block[$part] )* ) )
        // codegen.g:172:4: ^( PROOF execution_order common ( block[$part] )* )
        {
            if ( BACKTRACKING==0 ) 
            {
                 init_common(); 
            }
             MATCHT(PROOF, &FOLLOW_PROOF_in_proof51); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_execution_order_in_proof53);
            execution_order(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_common_in_proof55);
            common(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // codegen.g:172:53: ( block[$part] )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                case BLOCK:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // codegen.g:172:54: block[$part]
            	    {
            	        FOLLOWPUSH(FOLLOW_block_in_proof58);
            	        block(ctx, part);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproofEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleproofEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproofEx; /* Prevent compiler warnings */
    ruleproofEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end proof */

/** 
 * $ANTLR start execution_order
 * codegen.g:175:1: execution_order : ^( ORDER ( step )* ) ;
 */
static void
execution_order(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:176:2: ( ^( ORDER ( step )* ) )
        // codegen.g:176:4: ^( ORDER ( step )* )
        {
             MATCHT(ORDER, &FOLLOW_ORDER_in_execution_order74); 
            if  (HASEXCEPTION())
            {
                goto ruleexecution_orderEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:176:12: ( step )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2) 
                    {
                	case 1:
                	    // codegen.g:176:13: step
                	    {
                	        FOLLOWPUSH(FOLLOW_step_in_execution_order77);
                	        step(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleexecution_orderEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleexecution_orderEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexecution_orderEx; /* Prevent compiler warnings */
    ruleexecution_orderEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end execution_order */

/** 
 * $ANTLR start step
 * codegen.g:179:1: step : ^( ID ID ) ;
 */
static void
step(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:179:6: ( ^( ID ID ) )
        // codegen.g:179:8: ^( ID ID )
        {
             MATCHT(ID, &FOLLOW_ID_in_step92); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(ID, &FOLLOW_ID_in_step94); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulestepEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestepEx; /* Prevent compiler warnings */
    rulestepEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end step */

/** 
 * $ANTLR start common
 * codegen.g:182:1: common : ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) ;
 */
static void
common(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:182:8: ( ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) )
        // codegen.g:182:10: ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_common106); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(ID, &FOLLOW_ID_in_common109); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( BACKTRACKING==0 ) 
            {
                 TheModule = Common; 
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:182:47: ( param )?
                {
                    int alt3=2;
                    switch ( LA(1) ) 
                    {
                        case PARAM:
                        	{
                        		alt3=1;
                        	}
                            break;
                    }

                    switch (alt3) 
                    {
                	case 1:
                	    // codegen.g:182:47: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_common113);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:182:54: ( global )?
                {
                    int alt4=2;
                    switch ( LA(1) ) 
                    {
                        case VARIABLE:
                        	{
                        		alt4=1;
                        	}
                            break;
                    }

                    switch (alt4) 
                    {
                	case 1:
                	    // codegen.g:182:54: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_common116);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:182:62: ( function )?
                {
                    int alt5=2;
                    switch ( LA(1) ) 
                    {
                        case FUNCTION:
                        	{
                        		alt5=1;
                        	}
                            break;
                    }

                    switch (alt5) 
                    {
                	case 1:
                	    // codegen.g:182:62: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_common119);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecommonEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulecommonEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulecommonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommonEx; /* Prevent compiler warnings */
    rulecommonEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end common */

/** 
 * $ANTLR start block
 * codegen.g:185:1: block[const char *part] : ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) ;
 */
static void
block(pcodegen ctx, const char *part)
{   
    pANTLR3_BASE_TREE    ID1;

    /* Initialize rule variables
     */


    ID1       = NULL;

    {
        // codegen.g:186:2: ( ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) ) )
        // codegen.g:186:4: ^( BLOCK ^( ID ( param )? ( global )? ( function )? ) )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block135); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            ID1 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_block138); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( BACKTRACKING==0 ) 
            {

                			Linker *linker = new Linker((const char*)(ID1->getText(ID1))->chars, (const char*)(ID1->getText(ID1))->chars, getGlobalContext());
                			linker->LinkInModule(Common);
                			TheModule = linker->getModule();
                			
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:190:6: ( param )?
                {
                    int alt6=2;
                    switch ( LA(1) ) 
                    {
                        case PARAM:
                        	{
                        		alt6=1;
                        	}
                            break;
                    }

                    switch (alt6) 
                    {
                	case 1:
                	    // codegen.g:190:6: param
                	    {
                	        FOLLOWPUSH(FOLLOW_param_in_block142);
                	        param(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:190:13: ( global )?
                {
                    int alt7=2;
                    switch ( LA(1) ) 
                    {
                        case VARIABLE:
                        	{
                        		alt7=1;
                        	}
                            break;
                    }

                    switch (alt7) 
                    {
                	case 1:
                	    // codegen.g:190:13: global
                	    {
                	        FOLLOWPUSH(FOLLOW_global_in_block145);
                	        global(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                // codegen.g:190:21: ( function )?
                {
                    int alt8=2;
                    switch ( LA(1) ) 
                    {
                        case FUNCTION:
                        	{
                        		alt8=1;
                        	}
                            break;
                    }

                    switch (alt8) 
                    {
                	case 1:
                	    // codegen.g:190:21: function
                	    {
                	        FOLLOWPUSH(FOLLOW_function_in_block148);
                	        function(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                 TheModule->dump(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end block */

/** 
 * $ANTLR start param
 * codegen.g:193:1: param : ^( PARAM ( param_declaration )* ) ;
 */
static void
param(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:193:7: ( ^( PARAM ( param_declaration )* ) )
        // codegen.g:193:9: ^( PARAM ( param_declaration )* )
        {
             MATCHT(PARAM, &FOLLOW_PARAM_in_param165); 
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:193:17: ( param_declaration )*

                for (;;)
                {
                    int alt9=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt9=1;
                    	}
                        break;

                    }

                    switch (alt9) 
                    {
                	case 1:
                	    // codegen.g:193:18: param_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_param_declaration_in_param168);
                	        param_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleparamEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop9;	/* break out of the loop */
                	    break;
                    }
                }
                loop9: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleparamEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end param */

/** 
 * $ANTLR start global
 * codegen.g:196:1: global : ^( VARIABLE ( global_declaration )* ) ;
 */
static void
global(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:196:8: ( ^( VARIABLE ( global_declaration )* ) )
        // codegen.g:196:10: ^( VARIABLE ( global_declaration )* )
        {
             MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_global182); 
            if  (HASEXCEPTION())
            {
                goto ruleglobalEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:196:21: ( global_declaration )*

                for (;;)
                {
                    int alt10=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt10=1;
                    	}
                        break;

                    }

                    switch (alt10) 
                    {
                	case 1:
                	    // codegen.g:196:22: global_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_global_declaration_in_global185);
                	        global_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleglobalEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop10;	/* break out of the loop */
                	    break;
                    }
                }
                loop10: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleglobalEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobalEx; /* Prevent compiler warnings */
    ruleglobalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end global */

/** 
 * $ANTLR start function
 * codegen.g:199:1: function : ^( FUNCTION ( function_declaration )* ) ;
 */
static void
function(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:199:9: ( ^( FUNCTION ( function_declaration )* ) )
        // codegen.g:199:11: ^( FUNCTION ( function_declaration )* )
        {
             MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_function198); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:199:22: ( function_declaration )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) ) 
                    {
                    case ID:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11) 
                    {
                	case 1:
                	    // codegen.g:199:23: function_declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_function_declaration_in_function201);
                	        function_declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunctionEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end function */

/** 
 * $ANTLR start param_declaration
 * codegen.g:202:1: param_declaration returns [Value *value] : ^(par= ID type= type_declaration ( NUMBER | ) ) ;
 */
static Value *
param_declaration(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    par;
    pANTLR3_BASE_TREE    NUMBER2;
    NumberT * type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type NumberT *

    /* Initialize rule variables
     */


    par       = NULL;
    NUMBER2       = NULL;
    type = NULL;

    {
        // codegen.g:203:2: ( ^(par= ID type= type_declaration ( NUMBER | ) ) )
        // codegen.g:203:4: ^(par= ID type= type_declaration ( NUMBER | ) )
        {
            par = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_param_declaration222); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_param_declaration226);
            type=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            // codegen.g:204:4: ( NUMBER | )
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                case NUMBER:
                	{
                		alt12=1;
                	}
                    break;
                case UP:
                	{
                		alt12=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return value;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleparam_declarationEx;
                }

                switch (alt12) 
                {
            	case 1:
            	    // codegen.g:204:5: NUMBER
            	    {
            	        NUMBER2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_param_declaration232); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparam_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(type->getBitWidth(), (const char*)(NUMBER2->getText(NUMBER2))->chars, 10));
            	        }

            	    }
            	    break;
            	case 2:
            	    // codegen.g:206:6: 
            	    {
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            value= ConstantInt::get(getGlobalContext(), APInt(type->getBitWidth(), 0)); 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleparam_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                		Variable parx;
                		parx.value = value;
                		parx.type = type;
                		parx.variable = false;

                		Vars[(const char*) (par->getText(par))->chars] = parx;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparam_declarationEx; /* Prevent compiler warnings */
    ruleparam_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end param_declaration */

/** 
 * $ANTLR start global_declaration
 * codegen.g:217:1: global_declaration returns [Value *value] : ^(var= ID type_declaration ( NUMBER )? ) ;
 */
static Value *
global_declaration(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration3;
    #undef	RETURN_TYPE_type_declaration3
    #define	RETURN_TYPE_type_declaration3 NumberT *

    /* Initialize rule variables
     */


    var       = NULL;
    type_declaration3 = NULL;

    {
        // codegen.g:218:2: ( ^(var= ID type_declaration ( NUMBER )? ) )
        // codegen.g:218:4: ^(var= ID type_declaration ( NUMBER )? )
        {
            var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_global_declaration267); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_type_declaration_in_global_declaration269);
            type_declaration3=type_declaration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {
                 	value= new GlobalVariable(*TheModule, type_declaration3->getType(), false, GlobalVariable::ExternalLinkage, 0, (const char *) (var->getText(var))->chars);
                	
            }

            // codegen.g:220:4: ( NUMBER )?
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                    case NUMBER:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13) 
                {
            	case 1:
            	    // codegen.g:220:5: NUMBER
            	    {
            	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_global_declaration275); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobal_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return value;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleglobal_declarationEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                		Variable varx;
                		varx.value = value;
                		varx.type = type_declaration3;
                		varx.variable = true;

                		Vars[(const char*) (var->getText(var))->chars] = varx;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobal_declarationEx; /* Prevent compiler warnings */
    ruleglobal_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end global_declaration */

/** 
 * $ANTLR start argument_declaration
 * codegen.g:231:1: argument_declaration returns [Arg *arg] : ( ( ^( ID type_declaration ) )=> ^(var= ID type_declaration ) | (var= ID ) );
 */
static Arg *
argument_declaration(pcodegen ctx)
{   
    Arg * arg = NULL;

    pANTLR3_BASE_TREE    var;
    NumberT * type_declaration4;
    #undef	RETURN_TYPE_type_declaration4
    #define	RETURN_TYPE_type_declaration4 NumberT *

    /* Initialize rule variables
     */


    var       = NULL;
    type_declaration4 = NULL;

    {
        {
            //  codegen.g:232:2: ( ( ^( ID type_declaration ) )=> ^(var= ID type_declaration ) | (var= ID ) )
            
            ANTLR3_UINT32 alt14;

            alt14=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{

            		{
            		    int LA14_1 = LA(2);
            		    if ( (LA14_1 == DOWN) && (synpred1_codegen(ctx))) 
            		    {
            		        alt14=1;
            		    }
            		    else if ( (LA14_1 == UP || LA14_1 == ID) ) 
            		    {
            		        alt14=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return arg;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 14;
            		        EXCEPTION->state        = 1;


            		        goto ruleargument_declarationEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return arg;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleargument_declarationEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // codegen.g:232:4: ( ^( ID type_declaration ) )=> ^(var= ID type_declaration )
        	    {
        	        var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_argument_declaration308); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }
        	        FOLLOWPUSH(FOLLOW_type_declaration_in_argument_declaration310);
        	        type_declaration4=type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            		arg = new Arg();
        	            		arg->id = (const char*)(var->getText(var))->chars;
        	            		arg->type = type_declaration4;
        	            		arg->global_reference = false;
        	            		
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargument_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return arg;
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:238:4: (var= ID )
        	    {
        	        // codegen.g:238:4: (var= ID )
        	        // codegen.g:238:5: var= ID
        	        {
        	            var = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_argument_declaration321); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleargument_declarationEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return arg;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {

        	                		arg = new Arg();
        	                		arg->id = (const char*)(var->getText(var))->chars;
        	                		arg->type = Vars[arg->id].type;
        	                		arg->value = Vars[arg->id].value;
        	                		arg->global_reference = true;
        	                		
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargument_declarationEx; /* Prevent compiler warnings */
    ruleargument_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return arg;
}
/* $ANTLR end argument_declaration */

/** 
 * $ANTLR start type_declaration
 * codegen.g:247:1: type_declaration returns [NumberT *type] : ( group | interval );
 */
static NumberT *
type_declaration(pcodegen ctx)
{   
    NumberT * type = NULL;

    NumberT * group5;
    #undef	RETURN_TYPE_group5
    #define	RETURN_TYPE_group5 NumberT *

    NumberT * interval6;
    #undef	RETURN_TYPE_interval6
    #define	RETURN_TYPE_interval6 NumberT *

    /* Initialize rule variables
     */


    group5 = NULL;
    interval6 = NULL;

    {
        {
            //  codegen.g:248:2: ( group | interval )
            
            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) ) 
            {
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            	{
            		alt15=1;
            	}
                break;
            case INTERVAL:
            	{
            		alt15=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return type;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruletype_declarationEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // codegen.g:248:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_type_declaration339);
        	        group5=group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            type= group5; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:249:4: interval
        	    {
        	        FOLLOWPUSH(FOLLOW_interval_in_type_declaration346);
        	        interval6=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletype_declarationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            type= interval6; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_declarationEx; /* Prevent compiler warnings */
    ruletype_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end type_declaration */

/** 
 * $ANTLR start function_declaration
 * codegen.g:252:1: function_declaration returns [Function *func, vector<Arg *> outs, vector<Arg *> inps] : ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) ;
 */
static codegen_function_declaration_return
function_declaration(pcodegen ctx)
{   
    codegen_function_declaration_return retval;

    pANTLR3_BASE_TREE    ID7;
    Arg * out;
    #undef	RETURN_TYPE_out
    #define	RETURN_TYPE_out Arg *

    Arg * inp;
    #undef	RETURN_TYPE_inp
    #define	RETURN_TYPE_inp Arg *

    /* Initialize rule variables
     */


    ID7       = NULL;
    out = NULL;
    inp = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // codegen.g:253:2: ( ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? ) )
        // codegen.g:253:4: ^( ID ^( OUTPUT ( 'Void' | (out= argument_declaration )* ) ) ^( INP ( 'Void' | (inp= argument_declaration )* ) ) ( body )? )
        {
            ID7 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_function_declaration364); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(OUTPUT, &FOLLOW_OUTPUT_in_function_declaration367); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:253:18: ( 'Void' | (out= argument_declaration )* )
                {
                    int alt17=2;
                    switch ( LA(1) ) 
                    {
                    case 30:
                    	{
                    		alt17=1;
                    	}
                        break;
                    case UP:
                    case ID:
                    	{
                    		alt17=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 17;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;
                    }

                    switch (alt17) 
                    {
                	case 1:
                	    // codegen.g:253:19: 'Void'
                	    {
                	         MATCHT(30, &FOLLOW_30_in_function_declaration370); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;
                	case 2:
                	    // codegen.g:253:26: (out= argument_declaration )*
                	    {

                	        // codegen.g:253:26: (out= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt16=2;
                	            switch ( LA(1) ) 
                	            {
                	            case ID:
                	            	{
                	            		alt16=1;
                	            	}
                	                break;

                	            }

                	            switch (alt16) 
                	            {
                	        	case 1:
                	        	    // codegen.g:253:27: out= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration375);
                	        	        out=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }
                	        	        if ( BACKTRACKING==0 ) 
                	        	        {
                	        	             retval.outs.push_back(out); 
                	        	        }

                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop16;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop16: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }
             MATCHT(INP, &FOLLOW_INP_in_function_declaration388); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // codegen.g:254:10: ( 'Void' | (inp= argument_declaration )* )
                {
                    int alt19=2;
                    switch ( LA(1) ) 
                    {
                    case 30:
                    	{
                    		alt19=1;
                    	}
                        break;
                    case UP:
                    case ID:
                    	{
                    		alt19=2;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 0;


                        goto rulefunction_declarationEx;
                    }

                    switch (alt19) 
                    {
                	case 1:
                	    // codegen.g:254:11: 'Void'
                	    {
                	         MATCHT(30, &FOLLOW_30_in_function_declaration391); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunction_declarationEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;
                	case 2:
                	    // codegen.g:254:18: (inp= argument_declaration )*
                	    {

                	        // codegen.g:254:18: (inp= argument_declaration )*

                	        for (;;)
                	        {
                	            int alt18=2;
                	            switch ( LA(1) ) 
                	            {
                	            case ID:
                	            	{
                	            		alt18=1;
                	            	}
                	                break;

                	            }

                	            switch (alt18) 
                	            {
                	        	case 1:
                	        	    // codegen.g:254:19: inp= argument_declaration
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_argument_declaration_in_function_declaration396);
                	        	        inp=argument_declaration(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulefunction_declarationEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return retval;
                	        	        }
                	        	        if ( BACKTRACKING==0 ) 
                	        	        {
                	        	             retval.inps.push_back(inp); 
                	        	        }

                	        	    }
                	        	    break;

                	        	default:
                	        	    goto loop18;	/* break out of the loop */
                	        	    break;
                	            }
                	        }
                	        loop18: ; /* Jump out to here if this rule does not match */


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulefunction_declarationEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
            }
            if ( BACKTRACKING==0 ) 
            {

                			vector<Type *> Inps;
                			
                			for(vector<Arg *>::iterator i = retval.inps.begin(); i != retval.inps.end(); i++) {
                				Inps.push_back((*i)->type->getType());
                			}

                			FunctionType *FT;
                			
                			if(retval.outs.size() == 0) {
                				FT = FunctionType::get(Type::getVoidTy(getGlobalContext()), Inps, false);
                			} else {
                				FT = FunctionType::get(retval.outs[0]->type->getType(), Inps, false);
                			}
                		
                			retval.func= Function::Create(FT, Function::ExternalLinkage, (const char*) (ID7->getText(ID7))->chars, TheModule);
                			
                			BasicBlock *entry_block = BasicBlock::Create(getGlobalContext(), "entry", retval.func);
                			
                			Builder.SetInsertPoint(entry_block);
                			
                			for(vector<Arg*>::iterator def = retval.outs.begin(); def != retval.outs.end(); def++) {
                				if(!(*def)->global_reference) {
                					Variable varx;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					Vars[(*def)->id] = varx;
                				}
                			}
                			
                			vector<Arg*>::iterator def = retval.inps.begin();
                			
                			for(Function::arg_iterator arg = retval.func->arg_begin(); arg != retval.func->arg_end(); arg++, def++) {
                				if(!(*def)->global_reference)
                				{
                					arg->setName((*def)->id);
                				
                					Variable varx;
                					
                					varx.value = arg;
                					varx.type = (*def)->type;
                					varx.variable = false;
                				
                					Vars[(*def)->id] = varx;
                				} else {
                					arg->setName((*def)->id);
                				
                					Builder.CreateStore(arg, (*def)->value);
                				}
                			}			
                		
            }

            // codegen.g:307:3: ( body )?
            {
                int alt20=2;
                switch ( LA(1) ) 
                {
                    case BODY:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20) 
                {
            	case 1:
            	    // codegen.g:307:3: body
            	    {
            	        FOLLOWPUSH(FOLLOW_body_in_function_declaration412);
            	        body(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_declarationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefunction_declarationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                	
                			if(retval.outs.size() > 0) {
                				Variable varx = Vars[retval.outs[0]->id];
                			
                				if(varx.variable) {
                					Builder.CreateRet(Builder.CreateLoad(varx.value, retval.outs[0]->id));
                				} else {
                					Builder.CreateRet(varx.value);
                				}
                			} else {
                				Builder.CreateRetVoid();
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunction_declarationEx; /* Prevent compiler warnings */
    rulefunction_declarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end function_declaration */

/** 
 * $ANTLR start body
 * codegen.g:323:1: body : ^( BODY ( statement )* ) ;
 */
static void
body(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        // codegen.g:323:6: ( ^( BODY ( statement )* ) )
        // codegen.g:323:8: ^( BODY ( statement )* )
        {
             MATCHT(BODY, &FOLLOW_BODY_in_body429); 
            if  (HASEXCEPTION())
            {
                goto rulebodyEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }

                // codegen.g:323:15: ( statement )*

                for (;;)
                {
                    int alt21=2;
                    switch ( LA(1) ) 
                    {
                    case 20:
                    case 39:
                    case 40:
                    case 41:
                    	{
                    		alt21=1;
                    	}
                        break;

                    }

                    switch (alt21) 
                    {
                	case 1:
                	    // codegen.g:323:15: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_body431);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulebodyEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop21;	/* break out of the loop */
                	    break;
                    }
                }
                loop21: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulebodyEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end body */

/** 
 * $ANTLR start statement
 * codegen.g:326:1: statement : ( assignment | function_call );
 */
static void
statement(pcodegen ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  codegen.g:327:2: ( assignment | function_call )
            
            ANTLR3_UINT32 alt22;

            alt22=2;

            switch ( LA(1) ) 
            {
            case 20:
            	{
            		alt22=1;
            	}
                break;
            case 39:
            case 40:
            case 41:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt22) 
            {
        	case 1:
        	    // codegen.g:327:4: assignment
        	    {
        	        FOLLOWPUSH(FOLLOW_assignment_in_statement445);
        	        assignment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:328:4: function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_statement450);
        	        function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start assignment
 * codegen.g:331:1: assignment returns [Value *value] : ^( ':=' ID expr[(const char*)$ID.text->chars] ) ;
 */
static Value *
assignment(pcodegen ctx)
{   
    Value * value = NULL;

    pANTLR3_BASE_TREE    ID8;
    codegen_expr_return expr9;
    #undef	RETURN_TYPE_expr9
    #define	RETURN_TYPE_expr9 codegen_expr_return

    /* Initialize rule variables
     */


    ID8       = NULL;

    {
        // codegen.g:332:2: ( ^( ':=' ID expr[(const char*)$ID.text->chars] ) )
        // codegen.g:332:4: ^( ':=' ID expr[(const char*)$ID.text->chars] )
        {
             MATCHT(20, &FOLLOW_20_in_assignment466); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            ID8 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_assignment468); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            FOLLOWPUSH(FOLLOW_expr_in_assignment470);
            expr9=expr(ctx, (const char*)(ID8->getText(ID8))->chars);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }
            if (HASFAILED())
            {
                return value;
            }
            if ( BACKTRACKING==0 ) 
            {

                			const char *id = (const char*) (ID8->getText(ID8))->chars;
                		
                			if(Vars.find(id) == Vars.end()) {
                				Variable varx;
                				varx.variable = false;
                				varx.type = expr9.type;
                				Vars[id] = varx;
                			}
                		
                			Variable dest = Vars[id];
                			
                			if(!dest.variable) {
                				dest.value = expr9.value;
                				
                				Vars[id] = dest;
                			} else {
                				value= Builder.CreateStore(Builder.CreateIntCast(expr9.value, dest.type->getType(), false), dest.value);			
                			}
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end assignment */

/** 
 * $ANTLR start function_call
 * codegen.g:355:1: function_call returns [Value *value, NumberT *type] : ( ^( 'Random' type_declaration ) | ^( 'CheckMembership' argument type_declaration ) | ^( 'Verify' expr[\"verify\"] ) );
 */
static codegen_function_call_return
function_call(pcodegen ctx)
{   
    codegen_function_call_return retval;

    NumberT * type_declaration10;
    #undef	RETURN_TYPE_type_declaration10
    #define	RETURN_TYPE_type_declaration10 NumberT *

    Value * argument11;
    #undef	RETURN_TYPE_argument11
    #define	RETURN_TYPE_argument11 Value *

    codegen_expr_return expr12;
    #undef	RETURN_TYPE_expr12
    #define	RETURN_TYPE_expr12 codegen_expr_return

    /* Initialize rule variables
     */


    type_declaration10 = NULL;
    argument11 = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  codegen.g:356:2: ( ^( 'Random' type_declaration ) | ^( 'CheckMembership' argument type_declaration ) | ^( 'Verify' expr[\"verify\"] ) )
            
            ANTLR3_UINT32 alt23;

            alt23=3;

            switch ( LA(1) ) 
            {
            case 39:
            	{
            		alt23=1;
            	}
                break;
            case 41:
            	{
            		alt23=2;
            	}
                break;
            case 40:
            	{
            		alt23=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 23;
                EXCEPTION->state        = 0;


                goto rulefunction_callEx;
            }

            switch (alt23) 
            {
        	case 1:
        	    // codegen.g:356:4: ^( 'Random' type_declaration )
        	    {
        	         MATCHT(39, &FOLLOW_39_in_function_call493); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_type_declaration_in_function_call495);
        	        type_declaration10=type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			Function *CalleeF = TheModule->getFunction("Random");
        	            			retval.value= Builder.CreateCall(CalleeF, vector<Value*>(), "calltmp");
        	            			
        	            			retval.type= type_declaration10;
        	            		
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:363:4: ^( 'CheckMembership' argument type_declaration )
        	    {
        	         MATCHT(41, &FOLLOW_41_in_function_call506); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_argument_in_function_call508);
        	        argument11=argument(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_type_declaration_in_function_call510);
        	        type_declaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			Function *CalleeF = TheModule->getFunction("CheckMembership");

        	            			vector<Value *> ArgsV;
        	            			
        	            			ArgsV.push_back(argument11);
        	            			
        	            			retval.value= Builder.CreateCall(CalleeF, ArgsV, "calltmp");
        	            			
        	            			retval.type= new GroupT(APInt(1024,0));			
        	            		
        	        }

        	    }
        	    break;
        	case 3:
        	    // codegen.g:375:4: ^( 'Verify' expr[\"verify\"] )
        	    {
        	         MATCHT(40, &FOLLOW_40_in_function_call521); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_function_call523);
        	        expr12=expr(ctx, "verify");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefunction_callEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			Function *CalleeF = TheModule->getFunction("Verify");
        	            			
        	            			vector<Value *> ArgsV;
        	            			
        	            			ArgsV.push_back(expr12.value);
        	            			
        	            			retval.value= Builder.CreateCall(CalleeF, ArgsV, "calltmp");
        	            			
        	            			retval.type= new GroupT(APInt(1024,0));			
        	            		
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end function_call */

/** 
 * $ANTLR start argument
 * codegen.g:389:1: argument returns [Value *value] : ( expr[\"arg\"] | group );
 */
static Value *
argument(pcodegen ctx)
{   
    Value * value = NULL;

    codegen_expr_return expr13;
    #undef	RETURN_TYPE_expr13
    #define	RETURN_TYPE_expr13 codegen_expr_return

    /* Initialize rule variables
     */


    {
        {
            //  codegen.g:390:2: ( expr[\"arg\"] | group )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case ID:
            case NUMBER:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            	{
            		alt24=1;
            	}
                break;
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return value;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // codegen.g:390:4: expr[\"arg\"]
        	    {
        	        FOLLOWPUSH(FOLLOW_expr_in_argument546);
        	        expr13=expr(ctx, "arg");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             value= expr13.value; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:391:4: group
        	    {
        	        FOLLOWPUSH(FOLLOW_group_in_argument554);
        	        group(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return value;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end argument */

/** 
 * $ANTLR start group
 * codegen.g:394:1: group returns [NumberT *type] : ( 'Z' | ^( 'Prime' expr[\"group\"] ) | ^( 'Int' expr[\"group\"] ) | ^( 'Zmod+' expr[\"group\"] ) | ^( 'Zmod*' expr[\"group\"] ) );
 */
static NumberT *
group(pcodegen ctx)
{   
    NumberT * type = NULL;

    codegen_expr_return expr14;
    #undef	RETURN_TYPE_expr14
    #define	RETURN_TYPE_expr14 codegen_expr_return

    codegen_expr_return expr15;
    #undef	RETURN_TYPE_expr15
    #define	RETURN_TYPE_expr15 codegen_expr_return

    codegen_expr_return expr16;
    #undef	RETURN_TYPE_expr16
    #define	RETURN_TYPE_expr16 codegen_expr_return

    codegen_expr_return expr17;
    #undef	RETURN_TYPE_expr17
    #define	RETURN_TYPE_expr17 codegen_expr_return

    /* Initialize rule variables
     */


    {
        {
            //  codegen.g:395:2: ( 'Z' | ^( 'Prime' expr[\"group\"] ) | ^( 'Int' expr[\"group\"] ) | ^( 'Zmod+' expr[\"group\"] ) | ^( 'Zmod*' expr[\"group\"] ) )
            
            ANTLR3_UINT32 alt25;

            alt25=5;

            switch ( LA(1) ) 
            {
            case 47:
            	{
            		alt25=1;
            	}
                break;
            case 45:
            	{
            		alt25=2;
            	}
                break;
            case 46:
            	{
            		alt25=3;
            	}
                break;
            case 43:
            	{
            		alt25=4;
            	}
                break;
            case 44:
            	{
            		alt25=5;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return type;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto rulegroupEx;
            }

            switch (alt25) 
            {
        	case 1:
        	    // codegen.g:395:4: 'Z'
        	    {
        	         MATCHT(47, &FOLLOW_47_in_group569); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             type= new NumberT(32); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:396:4: ^( 'Prime' expr[\"group\"] )
        	    {
        	         MATCHT(45, &FOLLOW_45_in_group577); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_group579);
        	        expr14=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             type= new NumberT(static_cast<ConstantInt*>(expr14.value)->getValue().getLimitedValue(1024)); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // codegen.g:397:4: ^( 'Int' expr[\"group\"] )
        	    {
        	         MATCHT(46, &FOLLOW_46_in_group589); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_group591);
        	        expr15=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             type= new NumberT(static_cast<ConstantInt*>(expr15.value)->getValue().getLimitedValue(1024)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // codegen.g:398:4: ^( 'Zmod+' expr[\"group\"] )
        	    {
        	         MATCHT(43, &FOLLOW_43_in_group601); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_group603);
        	        expr16=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             type= new GroupT(static_cast<ConstantInt*>(expr16.value)->getValue()); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // codegen.g:399:4: ^( 'Zmod*' expr[\"group\"] )
        	    {
        	         MATCHT(44, &FOLLOW_44_in_group613); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_group615);
        	        expr17=expr(ctx, "group");

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegroupEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return type;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             type= new GroupT(static_cast<ConstantInt*>(expr17.value)->getValue()); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegroupEx; /* Prevent compiler warnings */
    rulegroupEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end group */

/** 
 * $ANTLR start alias
 * codegen.g:402:1: alias returns [NumberT *type] : ^( '=' ID ( group | interval ) ) ;
 */
static NumberT *
alias(pcodegen ctx)
{   
    NumberT * type = NULL;

    pANTLR3_BASE_TREE    ID20;
    NumberT * group18;
    #undef	RETURN_TYPE_group18
    #define	RETURN_TYPE_group18 NumberT *

    NumberT * interval19;
    #undef	RETURN_TYPE_interval19
    #define	RETURN_TYPE_interval19 NumberT *

    /* Initialize rule variables
     */


    ID20       = NULL;
    group18 = NULL;
    interval19 = NULL;

    {
        // codegen.g:403:2: ( ^( '=' ID ( group | interval ) ) )
        // codegen.g:403:4: ^( '=' ID ( group | interval ) )
        {
             MATCHT(42, &FOLLOW_42_in_alias635); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            ID20 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_alias637); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            // codegen.g:403:13: ( group | interval )
            {
                int alt26=2;
                switch ( LA(1) ) 
                {
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                	{
                		alt26=1;
                	}
                    break;
                case INTERVAL:
                	{
                		alt26=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return type;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto rulealiasEx;
                }

                switch (alt26) 
                {
            	case 1:
            	    // codegen.g:403:14: group
            	    {
            	        FOLLOWPUSH(FOLLOW_group_in_alias640);
            	        group18=group(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            type=group18; 
            	        }

            	    }
            	    break;
            	case 2:
            	    // codegen.g:403:44: interval
            	    {
            	        FOLLOWPUSH(FOLLOW_interval_in_alias646);
            	        interval19=interval(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealiasEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return type;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            type=interval19; 
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealiasEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            if ( BACKTRACKING==0 ) 
            {

                			Types[(const char*)(ID20->getText(ID20))->chars] = type;
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end alias */

/** 
 * $ANTLR start interval
 * codegen.g:409:1: interval returns [NumberT *type] : ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) ;
 */
static NumberT *
interval(pcodegen ctx)
{   
    NumberT * type = NULL;

    /* Initialize rule variables
     */


    {
        // codegen.g:410:2: ( ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] ) )
        // codegen.g:410:3: ^( INTERVAL expr[\"lhs\"] expr[\"rhs\"] )
        {
             MATCHT(INTERVAL, &FOLLOW_INTERVAL_in_interval670); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            FOLLOWPUSH(FOLLOW_expr_in_interval672);
            expr(ctx, "lhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            FOLLOWPUSH(FOLLOW_expr_in_interval675);
            expr(ctx, "rhs");

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }
            if (HASFAILED())
            {
                return type;
            }
            if ( BACKTRACKING==0 ) 
            {
                type= new GroupT(APInt(32, 0)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintervalEx; /* Prevent compiler warnings */
    ruleintervalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return type;
}
/* $ANTLR end interval */

/** 
 * $ANTLR start expr
 * codegen.g:413:1: expr[const char *id] returns [Value *value, NumberT *type] : ( ( '-' val= expr[$id] ) | ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call | ID | NUMBER );
 */
static codegen_expr_return
expr(pcodegen ctx, const char *id)
{   
    codegen_expr_return retval;

    pANTLR3_BASE_TREE    ID22;
    pANTLR3_BASE_TREE    NUMBER23;
    codegen_expr_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val codegen_expr_return

    codegen_expr_return lhs;
    #undef	RETURN_TYPE_lhs
    #define	RETURN_TYPE_lhs codegen_expr_return

    codegen_expr_return rhs;
    #undef	RETURN_TYPE_rhs
    #define	RETURN_TYPE_rhs codegen_expr_return

    codegen_function_call_return function_call21;
    #undef	RETURN_TYPE_function_call21
    #define	RETURN_TYPE_function_call21 codegen_function_call_return

    /* Initialize rule variables
     */


    ID22       = NULL;
    NUMBER23       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  codegen.g:414:2: ( ( '-' val= expr[$id] ) | ^( '+' lhs= expr[$id] rhs= expr[$id] ) | ^( '-' lhs= expr[$id] rhs= expr[$id] ) | ^( '*' lhs= expr[$id] rhs= expr[$id] ) | ^( '^' lhs= expr[$id] rhs= expr[$id] ) | ^( '==' lhs= expr[$id] rhs= expr[$id] ) | ^( '!=' lhs= expr[$id] rhs= expr[$id] ) | function_call | ID | NUMBER )
            
            ANTLR3_UINT32 alt27;

            alt27=10;

            switch ( LA(1) ) 
            {
            case 36:
            	{
            		switch ( LA(2) ) 
            		{
            		case DOWN:
            			{
            				alt27=3;
            			}
            		    break;
            		case ID:
            		case NUMBER:
            		case 33:
            		case 34:
            		case 35:
            		case 36:
            		case 37:
            		case 38:
            		case 39:
            		case 40:
            		case 41:
            			{
            				alt27=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 27;
            		    EXCEPTION->state        = 1;


            		    goto ruleexprEx;
            		}

            	}
                break;
            case 35:
            	{
            		alt27=2;
            	}
                break;
            case 38:
            	{
            		alt27=4;
            	}
                break;
            case 37:
            	{
            		alt27=5;
            	}
                break;
            case 33:
            	{
            		alt27=6;
            	}
                break;
            case 34:
            	{
            		alt27=7;
            	}
                break;
            case 39:
            case 40:
            case 41:
            	{
            		alt27=8;
            	}
                break;
            case ID:
            	{
            		alt27=9;
            	}
                break;
            case NUMBER:
            	{
            		alt27=10;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleexprEx;
            }

            switch (alt27) 
            {
        	case 1:
        	    // codegen.g:414:4: ( '-' val= expr[$id] )
        	    {
        	        // codegen.g:414:4: ( '-' val= expr[$id] )
        	        // codegen.g:414:5: '-' val= expr[$id]
        	        {
        	             MATCHT(36, &FOLLOW_36_in_expr697); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexprEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            FOLLOWPUSH(FOLLOW_expr_in_expr701);
        	            val=expr(ctx, id);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleexprEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	        }

        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= val.type; retval.value= retval.type->createNeg(val.value); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // codegen.g:415:4: ^( '+' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(35, &FOLLOW_35_in_expr711); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr715);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr720);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= *lhs.type + *rhs.type; retval.value= retval.type->createAdd(lhs.value, rhs.value); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // codegen.g:416:4: ^( '-' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(36, &FOLLOW_36_in_expr730); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr734);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr739);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= *lhs.type - *rhs.type; retval.value= retval.type->createSub(lhs.value, rhs.value); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // codegen.g:417:4: ^( '*' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(38, &FOLLOW_38_in_expr749); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr753);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr758);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= *lhs.type * *rhs.type; retval.value= retval.type->createMul(lhs.value, rhs.value); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // codegen.g:418:4: ^( '^' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(37, &FOLLOW_37_in_expr768); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr772);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr777);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= *lhs.type ^ *rhs.type; retval.value= retval.type->createExp(lhs.value, rhs.value); 
        	        }

        	    }
        	    break;
        	case 6:
        	    // codegen.g:419:4: ^( '==' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(33, &FOLLOW_33_in_expr787); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr791);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr796);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.value= Builder.CreateICmpEQ(lhs.value, rhs.value, id);
        	        }

        	    }
        	    break;
        	case 7:
        	    // codegen.g:420:4: ^( '!=' lhs= expr[$id] rhs= expr[$id] )
        	    {
        	         MATCHT(34, &FOLLOW_34_in_expr806); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr810);
        	        lhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_expr_in_expr815);
        	        rhs=expr(ctx, id);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.value= Builder.CreateICmpNE(lhs.value, rhs.value, id);
        	        }

        	    }
        	    break;
        	case 8:
        	    // codegen.g:421:4: function_call
        	    {
        	        FOLLOWPUSH(FOLLOW_function_call_in_expr824);
        	        function_call21=function_call(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= function_call21.type; retval.value= function_call21.value;
        	        }

        	    }
        	    break;
        	case 9:
        	    // codegen.g:422:4: ID
        	    {
        	        ID22 = (pANTLR3_BASE_TREE) MATCHT(ID, &FOLLOW_ID_in_expr831); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	            			Variable varx = Vars[(const char *) (ID22->getText(ID22))->chars];
        	            			retval.type= varx.type;
        	            			if(!varx.variable) {
        	            				retval.value= Builder.CreateIntCast(varx.value, IntegerType::get(getGlobalContext(), 1024), false, (const char*)(ID22->getText(ID22))->chars);
        	            			} else {
        	            				retval.value= Builder.CreateIntCast(Builder.CreateLoad(varx.value, (const char*) (ID22->getText(ID22))->chars), IntegerType::get(getGlobalContext(), 1024), false, (const char*)(ID22->getText(ID22))->chars);
        	            			}
        	            		
        	        }

        	    }
        	    break;
        	case 10:
        	    // codegen.g:432:4: NUMBER
        	    {
        	        NUMBER23 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expr840); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexprEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            retval.type= new NumberT(1024); retval.value= ConstantInt::get(getGlobalContext(), APInt(1024, (const char*) (NUMBER23->getText(NUMBER23))->chars, 10));
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end expr */

// $ANTLR start synpred1_codegen
static void synpred1_codegen_fragment(pcodegen ctx ) 
{
    // codegen.g:232:4: ( ^( ID type_declaration ) )
    // codegen.g:232:5: ^( ID type_declaration )
    {
         MATCHT(ID, &FOLLOW_ID_in_synpred1_codegen298); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_type_declaration_in_synpred1_codegen300);
        type_declaration(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_codegenEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_codegenEx; /* Prevent compiler warnings */
rulesynpred1_codegenEx: ;

}
// $ANTLR end synpred1_codegen
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_codegen(pcodegen ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_codegen_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
